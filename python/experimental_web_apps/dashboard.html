<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
  <title>Vocal Analyzer – Melodyne Style</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root {
      --bg: #020617;
      --panel: radial-gradient(circle at top left, #0f172a 0, #020617 60%);
      --card: radial-gradient(circle at top left, #111827 0, #0a0f1c 60%);
      --text: #e5e7eb;
      --muted: #9ca3af;
      --accent: #38bdf8;
      --accent2: #fbbf24;
      --border: #1f2937;
      --danger: #ef4444;
      --success: #22c55e;
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text);
      margin: 0;
    }

    .page {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px 16px 36px;
    }

    h1 {
      font-size: 24px;
      margin: 0 0 6px;
    }

    p {
      margin: 0 0 14px;
      color: var(--muted);
      font-size: 14px;
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 14px;
      margin-top: 12px;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 16px 32px rgba(0, 0, 0, 0.45);
    }

    .panel h3 {
      margin: 0 0 6px;
      font-size: 15px;
      color: var(--text);
    }

    .status {
      color: var(--muted);
      font-size: 12px;
      margin-top: 6px;
    }

    input[type="file"] {
      margin-top: 6px;
      font-size: 13px;
      color: var(--text);
    }

    button {
      border-radius: 999px;
      border: 1px solid #2d3748;
      background: #0b1220;
      color: var(--text);
      font-size: 13px;
      padding: 7px 14px;
      cursor: pointer;
    }

    button.primary {
      background: linear-gradient(135deg, #4f46e5, #38bdf8);
      border-color: #4f46e5;
    }

    button:disabled {
      opacity: 0.55;
      cursor: default;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 14px;
      margin-top: 16px;
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 18px 36px rgba(0, 0, 0, 0.45);
    }

    .card h4 {
      margin: 0 0 6px;
      font-size: 15px;
      color: var(--text);
    }

    audio {
      width: 100%;
      margin-top: 8px;
    }

    .big-score {
      font-size: 32px;
      font-weight: 700;
      letter-spacing: 0.02em;
    }

    .score-label {
      font-size: 12px;
      color: var(--muted);
    }

    .metric-text {
      margin-top: 6px;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.5;
    }

    #graph-wrapper {
      margin-top: 10px;
      border: 1px solid var(--border);
      border-radius: 14px;
      background: var(--card);
      padding: 12px;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.6);
    }

    #graph-container {
      width: 100%;
      overflow-x: auto;
    }

    canvas {
      width: 100% !important;
      min-width: 900px;
      height: 440px !important;
      background: #0b1220;
      border-radius: 12px;
    }

    .toggle-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 8px;
      font-size: 12px;
      color: var(--muted);
    }

    .toggle-row button {
      border-radius: 999px;
      border: 1px solid #2d3748;
      background: #0b1220;
      color: var(--text);
      font-size: 12px;
      padding: 5px 12px;
    }

    .toggle-row button.active {
      background: var(--accent);
      border-color: var(--accent);
      color: #0b1220;
    }

    .legend {
      margin-top: 8px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.5;
    }

    .swatch {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 999px;
      margin-right: 4px;
      vertical-align: middle;
    }

    .error-text {
      color: var(--danger);
      font-size: 13px;
      margin-top: 6px;
      min-height: 18px;
    }

    .hidden {
      display: none !important;
    }
  </style>
</head>

<body>
  <div class="page">
    <h1>Vocal Analyzer – Melodyne Style</h1>
    <p>Record or upload a take, optionally add a reference, then visualize pitch accuracy with a Melodyne-style trace.</p>

    <div class="controls">
      <div class="panel">
        <h3>1. Upload vocal take</h3>
        <input type="file" id="fileInput" accept="audio/*" />
        <div class="status" id="fileStatus">No file selected.</div>
      </div>
      <div class="panel">
        <h3>2. Record from mic</h3>
        <button id="recordBtn">Start Recording</button>
        <button id="stopBtn" disabled>Stop</button>
        <div class="status" id="recordStatus">Not recording.</div>
        <audio id="recordedAudio" controls style="margin-top:8px; display:none;"></audio>
      </div>
      <div class="panel">
        <h3>3. Optional reference upload</h3>
        <input type="file" id="referenceInput" accept="audio/*" />
        <div class="status" id="referenceStatus">No reference selected.</div>
      </div>
      <div class="panel">
        <h3>4. Send to /analyze</h3>
        <button id="analyzeBtn" class="primary">Analyze</button>
        <div class="status" id="analyzeStatus">Waiting to analyze.</div>
        <div class="error-text" id="errorText"></div>
      </div>
    </div>

    <div class="grid" style="margin-top:18px;">
      <div class="card" id="vocalCard">
        <h4 id="vocalLabel">Vocal Take</h4>
        <audio id="audioVocal" controls>
          <source id="audioVocalSource" src="" type="audio/wav">
          Your browser does not support the audio element.
        </audio>
        <div style="margin-top:10px;">
          <div class="big-score" id="vocalScore">--</div>
          <div class="score-label" id="vocalScoreLabel"></div>
          <div class="metric-text">
            Mean error: <span id="vocalMean"></span>¢<br />
            RMS error: <span id="vocalRms"></span>¢<br />
            Duration: <span id="vocalDur"></span>s
          </div>
        </div>
      </div>

      <div class="card hidden" id="referenceCard">
        <h4 id="referenceLabel">Reference Take</h4>
        <audio id="audioRef" controls>
          <source id="audioRefSource" src="" type="audio/wav">
          Your browser does not support the audio element.
        </audio>
        <div style="margin-top:10px;">
          <div class="big-score" id="referenceScore">--</div>
          <div class="score-label" id="referenceScoreLabel"></div>
          <div class="metric-text">
            Mean error: <span id="referenceMean"></span>¢<br />
            RMS error: <span id="referenceRms"></span>¢<br />
            Duration: <span id="referenceDur"></span>s
          </div>
        </div>
      </div>
    </div>

    <h2 style="font-size:18px;margin:20px 0 10px;">Melodyne-Style Pitch View</h2>
    <div class="card">
      <div class="toggle-row">
        <span>Showing:</span>
        <button id="toggleVocal" class="active">Vocal</button>
        <button id="toggleReference" class="hidden">Reference</button>
        <span style="font-size:11px;">Line = pitch contour · Colored points = cents error</span>
      </div>
      <div id="graph-wrapper">
        <div id="graph-container">
          <canvas id="pitchChart"></canvas>
        </div>
        <div class="legend">
          <div>
            <span class="swatch" style="background:#22c55e;"></span>±20¢
            <span class="swatch" style="background:#eab308; margin-left:10px;"></span>20–40¢
            <span class="swatch" style="background:#ef4444; margin-left:10px;"></span>&gt;40¢
          </div>
        </div>
      </div>
    </div>

    <h2 style="font-size:18px;margin:18px 0 10px;">AI Feedback</h2>
    <div class="card">
      <div id="gptError" class="error-text" style="margin-top:0;"></div>
      <div id="gptSummary" style="font-size:14px;color:var(--text);margin-top:4px;"></div>
      <div id="gptModel" style="font-size:12px;color:var(--muted);margin-top:6px;"></div>
      <div style="margin-top:10px;display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:10px;" id="gptMetrics"></div>
      <div style="margin-top:10px;">
        <div style="font-size:13px;color:var(--muted);margin-bottom:6px;">Recommendations</div>
        <ul id="gptRecs" style="margin:0;padding-left:18px;color:var(--text);font-size:13px;line-height:1.5;"></ul>
      </div>
    </div>
  </div>

  <script>
    let audioContext;
    let mediaRecorder;
    let recordedChunks = [];
    let recordedBlobUrl;
    let playheadTime = 0;
    let playheadSource = null;
    let playheadRaf = null;

    const fileInput = document.getElementById('fileInput');
    const fileStatus = document.getElementById('fileStatus');
    const referenceInput = document.getElementById('referenceInput');
    const referenceStatus = document.getElementById('referenceStatus');
    const recordBtn = document.getElementById('recordBtn');
    const stopBtn = document.getElementById('stopBtn');
    const recordStatus = document.getElementById('recordStatus');
    const recordedAudio = document.getElementById('recordedAudio');
    const analyzeBtn = document.getElementById('analyzeBtn');
    const analyzeStatus = document.getElementById('analyzeStatus');
    const errorText = document.getElementById('errorText');

    const audioVocal = document.getElementById('audioVocal');
    const audioVocalSource = document.getElementById('audioVocalSource');
    const vocalLabel = document.getElementById('vocalLabel');
    const vocalScore = document.getElementById('vocalScore');
    const vocalScoreLabel = document.getElementById('vocalScoreLabel');
    const vocalMean = document.getElementById('vocalMean');
    const vocalRms = document.getElementById('vocalRms');
    const vocalDur = document.getElementById('vocalDur');

    const referenceCard = document.getElementById('referenceCard');
    const audioRef = document.getElementById('audioRef');
    const audioRefSource = document.getElementById('audioRefSource');
    const referenceLabel = document.getElementById('referenceLabel');
    const referenceScore = document.getElementById('referenceScore');
    const referenceScoreLabel = document.getElementById('referenceScoreLabel');
    const referenceMean = document.getElementById('referenceMean');
    const referenceRms = document.getElementById('referenceRms');
    const referenceDur = document.getElementById('referenceDur');

    const toggleVocal = document.getElementById('toggleVocal');
    const toggleReference = document.getElementById('toggleReference');

    const gptSummary = document.getElementById('gptSummary');
    const gptModel = document.getElementById('gptModel');
    const gptRecs = document.getElementById('gptRecs');
    const gptMetrics = document.getElementById('gptMetrics');
    const gptError = document.getElementById('gptError');

    const playheadPlugin = {
      id: 'playhead',
      afterDatasetsDraw(chart) {
        if (!Number.isFinite(playheadTime)) return;
        const xScale = chart.scales.x;
        if (!xScale) return;
        const x = xScale.getPixelForValue(playheadTime);
        if (Number.isNaN(x)) return;
        const ctx = chart.ctx;
        ctx.save();
        ctx.strokeStyle = 'rgba(255,255,255,0.85)';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(x, chart.chartArea.top);
        ctx.lineTo(x, chart.chartArea.bottom);
        ctx.stroke();
        ctx.restore();
      }
    };
    Chart.register(playheadPlugin);

    let pitchChart;
    const chartData = {
      datasets: [
        {
          label: 'Vocal Pitch',
          data: [],
          borderColor: '#38bdf8',
          pointBackgroundColor: [],
          pointRadius: 3,
          showLine: true,
          fill: false,
          parsing: false,
          spanGaps: true,
        },
        {
          label: 'Reference Pitch',
          data: [],
          borderColor: '#fbbf24',
          pointBackgroundColor: [],
          pointRadius: 3,
          showLine: true,
          fill: false,
          parsing: false,
          spanGaps: true,
          hidden: true,
        }
      ],
    };

    function initChart() {
      const ctx = document.getElementById('pitchChart').getContext('2d');
      pitchChart = new Chart(ctx, {
        type: 'scatter',
        data: chartData,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              type: 'linear',
              title: { display: true, text: 'Time (s)', color: '#9ca3af' },
              grid: { color: '#1f2937' },
              ticks: { color: '#9ca3af' },
            },
            y: {
              type: 'linear',
              title: { display: true, text: 'MIDI', color: '#9ca3af' },
              grid: { color: '#1f2937' },
              ticks: { color: '#9ca3af' },
            },
          },
          plugins: {
            legend: { labels: { color: '#e5e7eb' } },
            tooltip: {
              enabled: true,
              mode: 'nearest',
              intersect: false,
              callbacks: {
                label(context) {
                  const midi = context.parsed.y?.toFixed(2) ?? '--';
                  const time = context.parsed.x?.toFixed(2) ?? '--';
                  return `Time: ${time}s, MIDI: ${midi}`;
                }
              }
            }
          },
          interaction: { mode: 'nearest', intersect: false },
          animation: false,
        }
      });
    }

    function resetUI() {
      vocalLabel.textContent = 'Vocal Take';
      vocalScore.textContent = '--';
      vocalScoreLabel.textContent = '';
      vocalMean.textContent = '';
      vocalRms.textContent = '';
      vocalDur.textContent = '';
      audioVocalSource.src = '';
      audioVocal.load();

      referenceLabel.textContent = 'Reference Take';
      referenceScore.textContent = '--';
      referenceScoreLabel.textContent = '';
      referenceMean.textContent = '';
      referenceRms.textContent = '';
      referenceDur.textContent = '';
      audioRefSource.src = '';
      audioRef.load();
      referenceCard.classList.add('hidden');
      toggleReference.classList.add('hidden');

      chartData.datasets[0].data = [];
      chartData.datasets[0].pointBackgroundColor = [];
      chartData.datasets[1].data = [];
      chartData.datasets[1].pointBackgroundColor = [];
      chartData.datasets[0].hidden = false;
      chartData.datasets[1].hidden = true;
      syncToggleButtons();
      if (pitchChart) pitchChart.update();
      renderChatGPT(null, null);
    }

    function hzToMidi(hz) {
      if (!hz || hz <= 0) return null;
      return 69 + 12 * Math.log2(hz / 440);
    }

    function centsColor(cents) {
      if (cents === null || cents === undefined) return '#6b7280';
      const abs = Math.abs(cents);
      if (abs <= 20) return '#22c55e';
      if (abs <= 40) return '#eab308';
      return '#ef4444';
    }

    function buildContour(frames = []) {
      const points = [];
      const colors = [];
      for (const f of frames) {
        let midi = f.midi;
        if (midi === undefined || midi === null) {
          midi = hzToMidi(f.pitch);
        }
        if (midi === null || midi === undefined) continue;
        points.push({ x: f.time, y: midi });
        colors.push(centsColor(f.cents_error));
      }
      return { points, colors };
    }

    fileInput.addEventListener('change', () => {
      errorText.textContent = '';
      if (fileInput.files.length > 0) {
        fileStatus.textContent = `Selected: ${fileInput.files[0].name}`;
        const fileURL = URL.createObjectURL(fileInput.files[0]);
        audioVocalSource.src = fileURL;
        audioVocal.load();
        vocalLabel.textContent = fileInput.files[0].name;
      } else {
        fileStatus.textContent = 'No file selected.';
        audioVocalSource.src = '';
        audioVocal.load();
        vocalLabel.textContent = 'Vocal Take';
      }
    });

    referenceInput.addEventListener('change', () => {
      errorText.textContent = '';
      if (referenceInput.files.length > 0) {
        referenceStatus.textContent = `Reference: ${referenceInput.files[0].name}`;
      } else {
        referenceStatus.textContent = 'No reference selected.';
      }
    });

    recordBtn.addEventListener('click', async () => {
      errorText.textContent = '';
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        errorText.textContent = 'Your browser does not support recording.';
        return;
      }
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioContext = new AudioContext();
        mediaRecorder = new MediaRecorder(stream);
        recordedChunks = [];
        mediaRecorder.ondataavailable = e => {
          if (e.data.size > 0) recordedChunks.push(e.data);
        };
        mediaRecorder.onstop = () => {
          const blob = new Blob(recordedChunks, { type: 'audio/webm' });
          if (recordedBlobUrl) URL.revokeObjectURL(recordedBlobUrl);
          recordedBlobUrl = URL.createObjectURL(blob);
          recordedAudio.src = recordedBlobUrl;
          recordedAudio.style.display = 'block';
          vocalLabel.textContent = 'Recorded Take';
          audioVocalSource.src = recordedBlobUrl;
          audioVocal.load();
        };
        mediaRecorder.start();
        recordBtn.disabled = true;
        stopBtn.disabled = false;
        recordStatus.textContent = 'Recording...';
      } catch (err) {
        errorText.textContent = 'Error accessing microphone: ' + err.message;
      }
    });

    stopBtn.addEventListener('click', () => {
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
        recordBtn.disabled = false;
        stopBtn.disabled = true;
        recordStatus.textContent = 'Recording stopped.';
      }
    });

    analyzeBtn.addEventListener('click', async () => {
      errorText.textContent = '';
      analyzeStatus.textContent = 'Analyzing...';
      analyzeBtn.disabled = true;

      const formData = new FormData();
      let audioFile;

      if (fileInput.files.length > 0) {
        audioFile = fileInput.files[0];
      } else if (recordedAudio.src) {
        try {
          const response = await fetch(recordedBlobUrl);
          audioFile = await response.blob();
          audioFile.name = 'recorded.webm';
        } catch (err) {
          errorText.textContent = 'Error preparing recorded audio.';
          analyzeStatus.textContent = 'Waiting to analyze.';
          analyzeBtn.disabled = false;
          return;
        }
      } else {
        errorText.textContent = 'No audio file or recording available for analysis.';
        analyzeStatus.textContent = 'Waiting to analyze.';
        analyzeBtn.disabled = false;
        return;
      }

      formData.append('audio', audioFile);
      if (referenceInput.files.length > 0) {
        formData.append('reference', referenceInput.files[0]);
      }

      try {
        const response = await fetch('/analyze', {
          method: 'POST',
          body: formData,
        });
        if (!response.ok) {
          throw new Error(`Server error: ${response.statusText}`);
        }
        const data = await response.json();
        updateResults(data);
        analyzeStatus.textContent = 'Analysis complete.';
      } catch (err) {
        errorText.textContent = 'Analysis failed: ' + err.message;
        analyzeStatus.textContent = 'Waiting to analyze.';
      }
      analyzeBtn.disabled = false;
    });

    function fillTake(el, takeData) {
      const { labelEl, scoreEl, scoreLabelEl, meanEl, rmsEl, durEl, audioSourceEl, audioEl } = el;
      if (!takeData) {
        labelEl.textContent = '—';
        scoreEl.textContent = '--';
        scoreLabelEl.textContent = '';
        meanEl.textContent = '';
        rmsEl.textContent = '';
        durEl.textContent = '';
        audioSourceEl.src = '';
        audioEl.load();
        return;
      }
      labelEl.textContent = takeData.label || takeData.name || 'Take';
      const score = takeData.accuracy_score ?? takeData.score;
      scoreEl.textContent = Number.isFinite(score) ? Number(score).toFixed(2) : '--';
      scoreLabelEl.textContent = takeData.score_label || '';
      const mean = takeData.overall_mean_cents_error ?? takeData.mean_error;
      const rms = takeData.overall_rms_cents_error ?? takeData.rms_error;
      const dur = takeData.duration_seconds ?? takeData.duration;
      meanEl.textContent = Number.isFinite(mean) ? Number(mean).toFixed(2) : '';
      rmsEl.textContent = Number.isFinite(rms) ? Number(rms).toFixed(2) : '';
      durEl.textContent = Number.isFinite(dur) ? Number(dur).toFixed(2) : '';
      if (takeData.audio_url) {
        audioSourceEl.src = takeData.audio_url;
        audioEl.load();
      }
    }

    function updateResults(data) {
      if (!data) return;

      const vocalTake = data.vocal_take || data.take1 || null;
      const refTake = data.reference_take || data.take2 || null;

      fillTake({
        labelEl: vocalLabel,
        scoreEl: vocalScore,
        scoreLabelEl: vocalScoreLabel,
        meanEl: vocalMean,
        rmsEl: vocalRms,
        durEl: vocalDur,
        audioSourceEl: audioVocalSource,
        audioEl: audioVocal,
      }, vocalTake);

      if (refTake) {
        referenceCard.classList.remove('hidden');
        toggleReference.classList.remove('hidden');
        fillTake({
          labelEl: referenceLabel,
          scoreEl: referenceScore,
          scoreLabelEl: referenceScoreLabel,
          meanEl: referenceMean,
          rmsEl: referenceRms,
          durEl: referenceDur,
          audioSourceEl: audioRefSource,
          audioEl: audioRef,
        }, refTake);
      } else {
        referenceCard.classList.add('hidden');
        toggleReference.classList.add('hidden');
      }

      // Chart data
      if (vocalTake && Array.isArray(vocalTake.frames)) {
        const contour = buildContour(vocalTake.frames);
        chartData.datasets[0].data = contour.points;
        chartData.datasets[0].pointBackgroundColor = contour.colors;
      } else if (vocalTake && Array.isArray(vocalTake.pitch_data)) {
        const contour = buildContour(vocalTake.pitch_data);
        chartData.datasets[0].data = contour.points;
        chartData.datasets[0].pointBackgroundColor = contour.colors;
      } else {
        chartData.datasets[0].data = [];
        chartData.datasets[0].pointBackgroundColor = [];
      }

      if (refTake && (Array.isArray(refTake.frames) || Array.isArray(refTake.pitch_data))) {
        const contour = buildContour(refTake.frames || refTake.pitch_data || []);
        chartData.datasets[1].data = contour.points;
        chartData.datasets[1].pointBackgroundColor = contour.colors;
        chartData.datasets[1].hidden = false;
        toggleReference.classList.remove('hidden');
      } else {
        chartData.datasets[1].data = [];
        chartData.datasets[1].pointBackgroundColor = [];
        chartData.datasets[1].hidden = true;
        toggleReference.classList.add('hidden');
      }

      chartData.datasets[0].hidden = false;
      chartData.datasets[1].hidden = refTake ? false : true;
      syncToggleButtons();

      renderChatGPT(data.chatgpt_feedback, data.chatgpt_error);
      if (pitchChart) pitchChart.update();
    }

    function renderChatGPT(feedback, error) {
      gptError.textContent = error || '';
      if (!feedback) {
        gptSummary.textContent = '';
        gptModel.textContent = '';
        gptRecs.innerHTML = '';
        gptMetrics.innerHTML = '';
        return;
      }
      gptSummary.textContent = feedback.summary || '';
      const modelText = [feedback.model, feedback.source].filter(Boolean).join(' • ');
      gptModel.textContent = modelText ? `Model: ${modelText}` : '';

      const recs = Array.isArray(feedback.recommendations) ? feedback.recommendations : [];
      gptRecs.innerHTML = recs.map(r => `<li>${r}</li>`).join('');

      const metrics = feedback.metrics || {};
      const metricCards = Object.keys(metrics).map(key => {
        const m = metrics[key] || {};
        const score = m.score !== undefined && m.score !== null ? `${m.score}` : '—';
        const expl = m.explanation || '';
        const imp = m.improvement_recommendation || '';
        return `
          <div class="card" style="background:${'radial-gradient(circle at top left, #0b1220 0, #0a0f1a 60%)'};padding:10px;">
            <div style="font-size:13px;color:${'var(--muted)'};margin-bottom:4px;">${key}</div>
            <div style="font-size:22px;font-weight:600;color:${'var(--text)'};">${score}</div>
            ${expl ? `<div style="font-size:12px;color:${'var(--muted)'};margin-top:4px;">${expl}</div>` : ''}
            ${imp ? `<div style="font-size:12px;color:${'var(--success)'};margin-top:4px;">Improve: ${imp}</div>` : ''}
          </div>
        `;
      }).join('');
      gptMetrics.innerHTML = metricCards;
    }

    function syncToggleButtons() {
      if (!chartData.datasets[0].hidden) {
        toggleVocal.classList.add('active');
      } else {
        toggleVocal.classList.remove('active');
      }
      if (chartData.datasets[1].data.length === 0 || chartData.datasets[1].hidden) {
        toggleReference.classList.remove('active');
      } else {
        toggleReference.classList.add('active');
      }
    }

    toggleVocal.addEventListener('click', () => {
      chartData.datasets[0].hidden = !chartData.datasets[0].hidden;
      if (chartData.datasets[0].hidden && chartData.datasets[1].hidden && chartData.datasets[1].data.length > 0) {
        chartData.datasets[1].hidden = false; // ensure at least one line is visible
      }
      syncToggleButtons();
      if (pitchChart) pitchChart.update();
    });

    toggleReference.addEventListener('click', () => {
      if (chartData.datasets[1].data.length === 0) return;
      chartData.datasets[1].hidden = !chartData.datasets[1].hidden;
      if (chartData.datasets[0].hidden && chartData.datasets[1].hidden) {
        chartData.datasets[0].hidden = false; // ensure at least one line is visible
      }
      syncToggleButtons();
      if (pitchChart) pitchChart.update();
    });

    function attachPlayheadListeners(audioEl) {
      audioEl.addEventListener('play', () => startPlayheadLoop(audioEl));
      audioEl.addEventListener('pause', () => {
        if (playheadSource === audioEl) {
          playheadSource = null;
        }
      });
      audioEl.addEventListener('ended', () => {
        if (playheadSource === audioEl) {
          playheadSource = null;
        }
      });
    }

    function startPlayheadLoop(source) {
      playheadSource = source;
      if (playheadRaf) cancelAnimationFrame(playheadRaf);
      const tick = () => {
        if (!playheadSource || playheadSource.paused) {
          playheadRaf = null;
          return;
        }
        playheadTime = playheadSource.currentTime || 0;
        if (pitchChart) pitchChart.update('none');
        playheadRaf = requestAnimationFrame(tick);
      };
      tick();
    }

    function enableChartScrub() {
      if (!pitchChart) return;
      const canvas = pitchChart.canvas;
      const scrub = (evt) => {
        const rect = canvas.getBoundingClientRect();
        const xPixel = evt.clientX - rect.left;
        const xVal = pitchChart.scales.x.getValueForPixel(xPixel);
        if (!Number.isFinite(xVal)) return;
        playheadTime = Math.max(0, xVal);
        [audioVocal, audioRef].forEach(a => {
          if (a && a.src) {
            a.currentTime = Math.min(playheadTime, Number.isFinite(a.duration) ? a.duration : playheadTime);
          }
        });
        if (pitchChart) pitchChart.update();
      };
      let dragging = false;
      canvas.onpointerdown = (e) => { dragging = true; scrub(e); };
      canvas.onpointermove = (e) => { if (dragging) scrub(e); };
      window.onpointerup = () => { dragging = false; };
    }

    window.onload = () => {
      resetUI();
      initChart();
      attachPlayheadListeners(audioVocal);
      attachPlayheadListeners(audioRef);
      enableChartScrub();
    };
  </script>
</body>

</html>
