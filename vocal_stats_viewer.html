<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Vocal Pitch Stats Viewer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            margin: 20px;
            background: #111;
            color: #eee;
        }

        h1 {
            margin-bottom: 0.2rem;
        }

        .controls {
            margin: 1rem 0;
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        select {
            padding: 0.3rem 0.5rem;
            border-radius: 4px;
            border: 1px solid #555;
            background: #222;
            color: #eee;
        }

        .summary {
            margin-top: 0.5rem;
            font-size: 0.95rem;
        }

        canvas {
            max-width: 100%;
            background: #181818;
            border-radius: 8px;
            padding: 8px;
        }
    </style>
</head>

<body>
    <h1>Vocal Pitch Stats</h1>
    <p>Choose a take to view average cents off per note.</p>

    <div class="controls">
        <label for="takeSelect">Take:</label>
        <select id="takeSelect">
            <option value="">Loading...</option>
        </select>
        <span id="noteCount"></span>
    </div>

    <div class="summary" id="summary"></div>

    <canvas id="centsChart" height="120"></canvas>

    <script>
        const CSV_PATH = 'vocal_notes_stats.csv'; // same folder as this HTML

        let allData = [];
        let chartInstance = null;

        async function loadCSV(path) {
            const resp = await fetch(path);
            const text = await resp.text();

            const lines = text.trim().split(/\r?\n/);
            const header = lines[0].split(',');

            return lines.slice(1).map(line => {
                const cols = line.split(',');
                const obj = {};
                header.forEach((h, i) => {
                    obj[h] = cols[i];
                });
                // Cast numeric fields
                obj.note_index = parseInt(obj.note_index, 10);
                obj.start_time = parseFloat(obj.start_time);
                obj.end_time = parseFloat(obj.end_time);
                obj.duration = parseFloat(obj.duration);
                obj.measured_hz = parseFloat(obj.measured_hz);
                obj.target_hz = parseFloat(obj.target_hz);
                obj.cents_error = parseFloat(obj.cents_error);
                return obj;
            });
        }

        function populateTakeSelect(data) {
            const select = document.getElementById('takeSelect');
            const takes = Array.from(new Set(data.map(d => d.take))).sort();

            select.innerHTML = '';
            select.insertAdjacentHTML('beforeend', `<option value="">Select a take…</option>`);

            takes.forEach(t => {
                select.insertAdjacentHTML(
                    'beforeend',
                    `<option value="${t}">${t}</option>`
                );
            });
        }

        function computeStats(rows) {
            if (!rows.length) return null;
            const cents = rows.map(r => r.cents_error);
            const absCents = cents.map(c => Math.abs(c));

            const avg = cents.reduce((a, c) => a + c, 0) / cents.length;
            const avgAbs = absCents.reduce((a, c) => a + c, 0) / absCents.length;

            return {
                avgSigned: avg,
                avgAbs: avgAbs,
                count: cents.length,
            };
        }

        function updateSummary(stats, takeName) {
            const el = document.getElementById('summary');
            const countEl = document.getElementById('noteCount');

            if (!stats) {
                el.textContent = 'No notes for this take.';
                countEl.textContent = '';
                return;
            }

            const biasLabel =
                stats.avgSigned < -1 ? ' (tends flat)' :
                    stats.avgSigned > 1 ? ' (tends sharp)' :
                        ' (roughly centered)';

            el.innerHTML =
                `<strong>${takeName}</strong><br>` +
                `Average absolute error: ${stats.avgAbs.toFixed(2)} cents<br>` +
                `Average signed error: ${stats.avgSigned.toFixed(2)} cents${biasLabel}`;

            countEl.textContent = `Notes: ${stats.count}`;
        }

        function plotTake(rows, takeName) {
            const ctx = document.getElementById('centsChart').getContext('2d');

            const labels = rows.map(r => r.note_index);
            const cents = rows.map(r => r.cents_error);
            const noteNames = rows.map(r => r.note_name);

            // Destroy previous chart if any
            if (chartInstance) {
                chartInstance.destroy();
            }

            chartInstance = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: `Cents error per note (${takeName})`,
                        data: rows.map(r => ({ x: r.note_index, y: r.cents_error })),
                        pointRadius: 4,
                        pointHoverRadius: 6,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: (ctx) => {
                                    const idx = ctx.dataIndex;
                                    const r = rows[idx];
                                    return [
                                        `Note #${r.note_index} (${r.note_name})`,
                                        `Cents: ${r.cents_error.toFixed(2)}`,
                                        `Time: ${r.start_time.toFixed(2)}–${r.end_time.toFixed(2)} s`,
                                    ];
                                }
                            }
                        },
                        legend: {
                            labels: {
                                color: '#eee'
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Note Index'
                            },
                            ticks: { color: '#ccc' },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Cents error'
                            },
                            ticks: { color: '#ccc' },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        }
                    }
                }
            });
        }

        async function init() {
            try {
                allData = await loadCSV(CSV_PATH);
                populateTakeSelect(allData);

                const select = document.getElementById('takeSelect');
                select.addEventListener('change', () => {
                    const take = select.value;
                    if (!take) {
                        updateSummary(null, '');
                        if (chartInstance) chartInstance.destroy();
                        return;
                    }
                    const rows = allData.filter(d => d.take === take);
                    const stats = computeStats(rows);
                    updateSummary(stats, take);
                    plotTake(rows, take);
                });

            } catch (err) {
                console.error(err);
                alert('Error loading CSV. Check that vocal_notes_stats.csv is in the same folder as this HTML.');
            }
        }

        init();
    </script>
</body>

</html>