<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Vocal Note Timeline (Melodyne Style)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            margin: 20px;
            background: #111;
            color: #eee;
        }

        h1 {
            margin-bottom: 0.2rem;
        }

        .controls {
            margin: 1rem 0;
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        select {
            padding: 0.3rem 0.5rem;
            border-radius: 4px;
            border: 1px solid #555;
            background: #222;
            color: #eee;
        }

        .summary {
            margin-top: 0.5rem;
            font-size: 0.95rem;
        }

        #chartWrapper {
            margin-top: 1rem;
            width: 100%;
            max-width: 1000px;
            height: 380px;
        }

        canvas {
            width: 100% !important;
            height: 100% !important;
            background: #181818;
            border-radius: 8px;
            padding: 8px;
        }
    </style>
</head>

<body>
    <h1>Vocal Note Timeline</h1>
    <p>Notes over time (like Melodyne), colored by cents off.</p>

    <div class="controls">
        <label for="takeSelect">Take:</label>
        <select id="takeSelect">
            <option value="">Loading…</option>
        </select>
        <span id="noteCount"></span>
    </div>

    <div class="summary" id="summary"></div>

    <div id="chartWrapper">
        <canvas id="timelineChart"></canvas>
    </div>

    <script>
        const CSV_PATH = 'vocal_notes_stats.csv';

        let allData = [];
        let chartInstance = null;

        function hzToMidi(freq) {
            return 69 + 12 * Math.log2(freq / 440.0);
        }

        function midiToNoteName(midi) {
            const names = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const m = Math.round(midi);
            const name = names[m % 12];
            const octave = Math.floor(m / 12) - 1;
            return `${name}${octave}`;
        }

        async function loadCSV(path) {
            const resp = await fetch(path);
            const text = await resp.text();

            const lines = text.trim().split(/\r?\n/);
            const header = lines[0].split(',');

            return lines.slice(1).map(line => {
                const cols = line.split(',');
                const obj = {};
                header.forEach((h, i) => {
                    obj[h] = cols[i];
                });
                obj.note_index = parseInt(obj.note_index, 10);
                obj.start_time = parseFloat(obj.start_time);
                obj.end_time = parseFloat(obj.end_time);
                obj.duration = parseFloat(obj.duration);
                obj.measured_hz = parseFloat(obj.measured_hz);
                obj.target_hz = parseFloat(obj.target_hz);
                obj.cents_error = parseFloat(obj.cents_error);

                // for Melodyne-style Y axis: convert sung pitch to MIDI
                obj.midi = hzToMidi(obj.measured_hz);
                return obj;
            });
        }

        function populateTakeSelect(data) {
            const select = document.getElementById('takeSelect');
            const takes = Array.from(new Set(data.map(d => d.take))).sort();

            select.innerHTML = '';
            select.insertAdjacentHTML(
                'beforeend',
                `<option value="">Select a take…</option>`
            );

            takes.forEach(t => {
                select.insertAdjacentHTML(
                    'beforeend',
                    `<option value="${t}">${t}</option>`
                );
            });
        }

        function computeStats(rows) {
            if (!rows.length) return null;
            const cents = rows.map(r => r.cents_error);
            const absCents = cents.map(c => Math.abs(c));

            const avgSigned = cents.reduce((a, c) => a + c, 0) / cents.length;
            const avgAbs = absCents.reduce((a, c) => a + c, 0) / absCents.length;

            const mean = avgSigned;
            const variance = cents.reduce((acc, c) => acc + Math.pow(c - mean, 2), 0) / cents.length;
            const stdDev = Math.sqrt(variance);

            return {
                avgSigned,
                avgAbs,
                stdDev,
                count: cents.length,
            };
        }

        function updateSummary(stats, takeName) {
            const el = document.getElementById('summary');
            const countEl = document.getElementById('noteCount');

            if (!stats) {
                el.textContent = 'No notes for this take.';
                countEl.textContent = '';
                return;
            }

            const biasLabel =
                stats.avgSigned < -1 ? ' (tends flat)' :
                    stats.avgSigned > 1 ? ' (tends sharp)' :
                        ' (roughly centered)';

            el.innerHTML =
                `<strong>${takeName}</strong><br>` +
                `Average absolute error: ${stats.avgAbs.toFixed(2)} cents<br>` +
                `Average signed error: ${stats.avgSigned.toFixed(2)} cents${biasLabel}<br>` +
                `Spread (std dev): ${stats.stdDev.toFixed(2)} cents`;

            countEl.textContent = `Notes: ${stats.count}`;
        }

        function colorForCents(absCents, maxAbs) {
            // 0 cents → green, maxAbs → red
            const clamped = Math.min(absCents / maxAbs, 1.0);
            const hue = 120 - 120 * clamped; // 120=green, 0=red
            return `hsl(${hue}, 100%, 50%)`;
        }

        function plotTake(rows, takeName) {
            const ctx = document.getElementById('timelineChart').getContext('2d');

            const maxAbs = rows.reduce(
                (m, r) => Math.max(m, Math.abs(r.cents_error)),
                1
            );

            const dataPoints = rows.map(r => ({
                x: r.start_time,       // show at note start time
                y: r.midi,             // actual pitch (MIDI)
                note: r.note_name,
                start: r.start_time,
                end: r.end_time,
                cents: r.cents_error,
            }));

            const midiValues = rows.map(r => r.midi);
            const minMidi = Math.min(...midiValues) - 1;
            const maxMidi = Math.max(...midiValues) + 1;

            if (chartInstance) {
                chartInstance.destroy();
            }

            chartInstance = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: `Notes over time (${takeName})`,
                        data: dataPoints,
                        pointRadius: ctx => {
                            const v = Math.abs(ctx.raw.cents);
                            return 4 + 4 * Math.min(v / maxAbs, 1.0); // bigger when more off
                        },
                        pointBackgroundColor: ctx => {
                            const v = Math.abs(ctx.raw.cents);
                            return colorForCents(v, maxAbs);
                        },
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#eee' }
                        },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => {
                                    const r = ctx.raw;
                                    const label = [
                                        `${r.note}  (${r.cents.toFixed(2)} cents)`,
                                        `Time: ${r.start.toFixed(2)}–${r.end.toFixed(2)} s`
                                    ];
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Time (s)',
                                color: '#eee'
                            },
                            ticks: { color: '#ccc' },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        },
                        y: {
                            type: 'linear',
                            min: minMidi,
                            max: maxMidi,
                            title: {
                                display: true,
                                text: 'Pitch (note lanes)',
                                color: '#eee'
                            },
                            ticks: {
                                stepSize: 1,
                                color: '#ccc',
                                callback: value => midiToNoteName(value)
                            },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        }
                    }
                }
            });
        }

        async function init() {
            try {
                allData = await loadCSV(CSV_PATH);
                populateTakeSelect(allData);

                const select = document.getElementById('takeSelect');
                select.addEventListener('change', () => {
                    const take = select.value;
                    if (!take) {
                        updateSummary(null, '');
                        if (chartInstance) chartInstance.destroy();
                        return;
                    }
                    const rows = allData.filter(d => d.take === take);
                    const stats = computeStats(rows);
                    updateSummary(stats, take);
                    plotTake(rows, take);
                });
            } catch (err) {
                console.error(err);
                alert('Error loading CSV. Make sure vocal_notes_stats.csv is in the same folder as this HTML.');
            }
        }

        init();
    </script>
</body>

</html>