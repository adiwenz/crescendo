<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Vocal Note Timeline (Melodyne Style)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            margin: 20px;
            background: #111;
            color: #eee;
        }

        h1 {
            margin-bottom: 0.2rem;
        }

        .controls {
            margin: 1rem 0;
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        select {
            padding: 0.3rem 0.5rem;
            border-radius: 4px;
            border: 1px solid #555;
            background: #222;
            color: #eee;
        }

        .summary {
            margin-top: 0.5rem;
            font-size: 0.95rem;
        }

        #chartWrapper {
            margin-top: 1rem;
            width: 100%;
            max-width: 1100px;
            height: 520px;
            /* taller so all notes fit */
        }

        canvas {
            width: 100% !important;
            height: 100% !important;
            background: #181818;
            border-radius: 8px;
            padding: 8px;
        }

        audio {
            width: 100%;
            max-width: 600px;
            margin-top: 0.5rem;
        }

        .scrubber {
            margin-top: 0.5rem;
            max-width: 600px;
            width: 100%;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .scrubber input[type="range"] {
            flex: 1;
            accent-color: #06b6d4;
        }

        .time-label {
            font-variant-numeric: tabular-nums;
            min-width: 110px;
            text-align: right;
            color: #ccc;
        }
    </style>
</head>

<body>
    <h1>Vocal Note Timeline</h1>
    <p>Melodyne-like note lanes with cents-based coloring and scrolling playhead.</p>

    <div class="controls">
        <label for="takeSelect">Take:</label>
        <select id="takeSelect">
            <option value="">Loading…</option>
        </select>
        <span id="noteCount"></span>
    </div>

    <audio id="audioPlayer" controls></audio>
    <div class="scrubber">
        <input type="range" id="timeScrubber" min="0" value="0" step="0.01" />
        <span class="time-label" id="timeLabel">0:00 / 0:00</span>
    </div>

    <div class="summary" id="summary"></div>

    <div id="chartWrapper">
        <canvas id="timelineChart"></canvas>
    </div>

    <script>
        const CSV_PATH = 'vocal_notes_stats.csv';
        const AUDIO_EXTENSION = '.wav';   // change to '.mp3' / '.m4a' if needed

        let allData = [];
        let chartInstance = null;
        let animationId = null;
        let dataTimeMin = 0;
        let dataTimeMax = 0;
        const PLAYBACK_WINDOW = 4.0;  // seconds around playhead
        let isScrubbing = false;

        function hzToMidi(freq) {
            return 69 + 12 * Math.log2(freq / 440.0);
        }

        function midiToNoteName(midi) {
            const names = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const m = Math.round(midi);
            const name = names[m % 12];
            const octave = Math.floor(m / 12) - 1;
            return `${name}${octave}`;
        }

        async function loadCSV(path) {
            const resp = await fetch(path);
            const text = await resp.text();

            const lines = text.trim().split(/\r?\n/);
            const header = lines[0].split(',');

            return lines.slice(1).map(line => {
                const cols = line.split(',');
                const obj = {};
                header.forEach((h, i) => {
                    obj[h] = cols[i];
                });
                obj.note_index = parseInt(obj.note_index, 10);
                obj.start_time = parseFloat(obj.start_time);
                obj.end_time = parseFloat(obj.end_time);
                obj.duration = parseFloat(obj.duration);
                obj.measured_hz = parseFloat(obj.measured_hz);
                obj.target_hz = parseFloat(obj.target_hz);
                obj.cents_error = parseFloat(obj.cents_error);
                obj.midi = hzToMidi(obj.measured_hz);
                return obj;
            });
        }

        function populateTakeSelect(data) {
            const select = document.getElementById('takeSelect');
            const takes = Array.from(new Set(data.map(d => d.take))).sort();

            select.innerHTML = '';
            select.insertAdjacentHTML(
                'beforeend',
                `<option value="">Select a take…</option>`
            );

            takes.forEach(t => {
                select.insertAdjacentHTML(
                    'beforeend',
                    `<option value="${t}">${t}</option>`
                );
            });
        }

        function computeStats(rows) {
            if (!rows.length) return null;
            const cents = rows.map(r => r.cents_error);
            const absCents = cents.map(c => Math.abs(c));

            const avgSigned = cents.reduce((a, c) => a + c, 0) / cents.length;
            const avgAbs = absCents.reduce((a, c) => a + c, 0) / absCents.length;

            const mean = avgSigned;
            const variance = cents.reduce((acc, c) => acc + Math.pow(c - mean, 2), 0) / cents.length;
            const stdDev = Math.sqrt(variance);

            return { avgSigned, avgAbs, stdDev, count: cents.length };
        }

        function updateSummary(stats, takeName) {
            const el = document.getElementById('summary');
            const countEl = document.getElementById('noteCount');

            if (!stats) {
                el.textContent = 'No notes for this take.';
                countEl.textContent = '';
                return;
            }

            const biasLabel =
                stats.avgSigned < -1 ? ' (tends flat)' :
                    stats.avgSigned > 1 ? ' (tends sharp)' :
                        ' (roughly centered)';

            el.innerHTML =
                `<strong>${takeName}</strong><br>` +
                `Average absolute error: ${stats.avgAbs.toFixed(2)} cents<br>` +
                `Average signed error: ${stats.avgSigned.toFixed(2)} cents${biasLabel}<br>` +
                `Spread (std dev): ${stats.stdDev.toFixed(2)} cents`;

            countEl.textContent = `Notes: ${stats.count}`;
        }

        function colorForCents(absCents, maxAbs) {
            const clamped = Math.min(absCents / maxAbs, 1.0);
            const hue = 120 - 120 * clamped; // 120=green, 0=red
            return `hsl(${hue}, 100%, 50%)`;
        }

        function plotTake(rows, takeName) {
            const ctx = document.getElementById('timelineChart').getContext('2d');

            const maxAbs = rows.reduce(
                (m, r) => Math.max(m, Math.abs(r.cents_error)),
                1
            );

            // Line data: horizontal segments per note (start -> end)
            const lineData = [];
            rows.forEach(r => {
                // skip totally zero-length notes if you want:
                // if (r.duration <= 0) return;

                lineData.push({
                    x: r.start_time,
                    y: r.midi,
                    cents: r.cents_error,
                    note: r.note_name,
                    start: r.start_time,
                    end: r.end_time
                });
                lineData.push({
                    x: r.end_time,
                    y: r.midi,
                    cents: r.cents_error,
                    note: r.note_name,
                    start: r.start_time,
                    end: r.end_time
                });
                // NaN break so Chart.js stops connecting to next note
                lineData.push({ x: NaN, y: NaN });
            });

            // Center points for tooltips
            const centerData = rows.map(r => ({
                x: (r.start_time + r.end_time) / 2.0,
                y: r.midi,
                cents: r.cents_error,
                note: r.note_name,
                start: r.start_time,
                end: r.end_time
            }));

            const midiValues = rows.map(r => r.midi);
            const minMidi = Math.min(...midiValues) - 1;
            const maxMidi = Math.max(...midiValues) + 1;

            dataTimeMin = Math.min(...rows.map(r => r.start_time));
            dataTimeMax = Math.max(...rows.map(r => r.end_time));

            if (chartInstance) {
                chartInstance.destroy();
            }

            chartInstance = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            // sustained note bars
                            label: 'Notes',
                            type: 'scatter',
                            data: lineData,
                            showLine: true,
                            pointRadius: 0,
                            borderWidth: 4,
                            segment: {
                                borderColor: ctx => {
                                    if (!ctx.p0 || !ctx.p0.raw || isNaN(ctx.p0.raw.x)) return 'transparent';
                                    const v = Math.abs(ctx.p0.raw.cents || 0);
                                    return colorForCents(v, maxAbs);
                                }
                            },
                            tooltip: { enabled: false } // tooltips handled by center dataset
                        },
                        {
                            // center dots for hover info
                            label: 'Pitch centers',
                            type: 'scatter',
                            data: centerData,
                            pointRadius: 4,
                            pointHoverRadius: 6,
                            pointBackgroundColor: ctx => {
                                const v = Math.abs(ctx.raw.cents);
                                return colorForCents(v, maxAbs);
                            }
                        },
                        {
                            // playhead line
                            label: 'Playhead',
                            type: 'scatter',
                            data: [
                                { x: dataTimeMin, y: minMidi },
                                { x: dataTimeMin, y: maxMidi }
                            ],
                            showLine: true,
                            borderColor: 'rgba(255,255,255,0.9)',
                            borderWidth: 1.5,
                            pointRadius: 0,
                            hitRadius: 0,
                            hoverRadius: 0,
                            tooltip: { enabled: false }
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#eee' }
                        },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => {
                                    const r = ctx.raw;
                                    if (!r || r.note === undefined) return '';
                                    return [
                                        `${r.note}  (${r.cents.toFixed(2)} cents)`,
                                        `Time: ${r.start.toFixed(2)}–${r.end.toFixed(2)} s`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            min: dataTimeMin,
                            max: dataTimeMin + PLAYBACK_WINDOW,
                            title: {
                                display: true,
                                text: 'Time (s)',
                                color: '#eee'
                            },
                            ticks: { color: '#ccc' },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        },
                        y: {
                            type: 'linear',
                            min: minMidi,
                            max: maxMidi,
                            title: {
                                display: true,
                                text: 'Pitch (note lanes)',
                                color: '#eee'
                            },
                            ticks: {
                                stepSize: 1,
                                autoSkip: false,        // <-- show every semitone
                                color: '#ccc',
                                callback: value => midiToNoteName(value)
                            },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        }
                    }
                }
            });
        }

        function attachAudioHandlers() {
            const audio = document.getElementById('audioPlayer');
            const scrubber = document.getElementById('timeScrubber');
            const timeLabel = document.getElementById('timeLabel');

            function cancelAnimation() {
                if (animationId !== null) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
            }

            function formatTime(secs) {
                if (!isFinite(secs)) return '0:00';
                const m = Math.floor(secs / 60);
                const s = Math.floor(secs % 60);
                return `${m}:${s.toString().padStart(2, '0')}`;
            }

            function updateTimeLabel() {
                const cur = formatTime(audio.currentTime || 0);
                const total = formatTime(audio.duration || 0);
                timeLabel.textContent = `${cur} / ${total}`;
            }

            function syncScrubber() {
                if (!scrubber) return;
                if (audio.duration) {
                    scrubber.max = audio.duration;
                }
                if (!isScrubbing) {
                    scrubber.value = audio.currentTime || 0;
                }
                updateTimeLabel();
            }

            function applyPlayhead(t) {
                if (!chartInstance) return;
                const ds = chartInstance.data.datasets[2]; // playhead dataset
                const yMin = chartInstance.options.scales.y.min;
                const yMax = chartInstance.options.scales.y.max;

                ds.data[0].x = t;
                ds.data[0].y = yMin;
                ds.data[1].x = t;
                ds.data[1].y = yMax;

                const halfWin = PLAYBACK_WINDOW / 2;
                let minX = t - halfWin;
                let maxX = t + halfWin;
                if (minX < dataTimeMin) {
                    minX = dataTimeMin;
                    maxX = minX + PLAYBACK_WINDOW;
                }
                if (maxX > dataTimeMax) {
                    maxX = dataTimeMax;
                    minX = maxX - PLAYBACK_WINDOW;
                }
                chartInstance.options.scales.x.min = minX;
                chartInstance.options.scales.x.max = maxX;

                chartInstance.update('none');
            }

            function updatePlayhead() {
                if (!chartInstance) return;

                const t = audio.currentTime;
                applyPlayhead(t);
                animationId = requestAnimationFrame(updatePlayhead);
            }

            audio.addEventListener('play', () => {
                cancelAnimation();
                animationId = requestAnimationFrame(updatePlayhead);
            });
            audio.addEventListener('pause', cancelAnimation);
            audio.addEventListener('ended', cancelAnimation);
            audio.addEventListener('timeupdate', syncScrubber);
            audio.addEventListener('loadedmetadata', syncScrubber);
            audio.addEventListener('seeking', () => {
                if (chartInstance) applyPlayhead(audio.currentTime);
                syncScrubber();
            });

            // Scrubber interactions
            if (scrubber) {
                const startScrub = () => { isScrubbing = true; };
                const endScrub = () => { isScrubbing = false; };

                scrubber.addEventListener('input', (e) => {
                    const newTime = parseFloat(e.target.value) || 0;
                    audio.currentTime = newTime;
                    syncScrubber();
                    if (chartInstance) applyPlayhead(newTime);
                });
                scrubber.addEventListener('mousedown', startScrub);
                scrubber.addEventListener('touchstart', startScrub);
                scrubber.addEventListener('mouseup', endScrub);
                scrubber.addEventListener('touchend', endScrub);
                scrubber.addEventListener('mouseleave', endScrub);
            }
        }

        async function init() {
            try {
                allData = await loadCSV(CSV_PATH);
                populateTakeSelect(allData);
                attachAudioHandlers();

                const select = document.getElementById('takeSelect');
                const audio = document.getElementById('audioPlayer');

                select.addEventListener('change', () => {
                    const take = select.value;
                    if (!take) {
                        updateSummary(null, '');
                        if (chartInstance) chartInstance.destroy();
                        audio.removeAttribute('src');
                        audio.load();
                        return;
                    }

                    const rows = allData.filter(d => d.take === take);
                    const stats = computeStats(rows);
                    updateSummary(stats, take);
                    plotTake(rows, take);

                    const src = `${take}${AUDIO_EXTENSION}`;
                    audio.src = src;
                    audio.load();
                });

            } catch (err) {
                console.error(err);
                alert('Error loading CSV. Make sure vocal_notes_stats.csv is in the same folder as this HTML.');
            }
        }

        init();
    </script>
</body>

</html>
