<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Vocal Note Timeline (Melodyne Style)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            margin: 20px;
            background: #111;
            color: #eee;
        }

        h1 {
            margin-bottom: 0.2rem;
        }

        .controls {
            margin: 1rem 0;
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        select {
            padding: 0.3rem 0.5rem;
            border-radius: 4px;
            border: 1px solid #555;
            background: #222;
            color: #eee;
        }

        .summary {
            margin-top: 0.5rem;
            font-size: 0.95rem;
        }

        #chartWrapper {
            margin-top: 1rem;
            width: 100%;
            max-width: 1100px;
            height: 520px;
            /* taller so all notes fit */
        }

        canvas {
            width: 100% !important;
            height: 100% !important;
            background: #181818;
            border-radius: 8px;
            padding: 8px;
        }

        audio {
            width: 100%;
            max-width: 600px;
            margin-top: 0.5rem;
        }

    </style>
</head>

<body>
    <h1>Vocal Note Timeline</h1>
    <p>Melodyne-like note lanes with cents-based coloring and scrolling playhead.</p>

    <div class="controls">
        <label for="takeSelect">Take:</label>
        <select id="takeSelect">
            <option value="">Loading…</option>
        </select>
        <span id="noteCount"></span>
    </div>

    <audio id="audioPlayer" controls></audio>

    <div class="summary" id="summary"></div>

    <div id="chartWrapper">
        <canvas id="timelineChart"></canvas>
    </div>

    <script>
        // Simple helper to parse float arrays stored either as semicolon strings, JSON-ish lists,
        // and optionally wrapped in quotes
        const parseFloatArray = (val) => {
            if (val === undefined || val === null) return [];
            if (Array.isArray(val)) return val.map(Number).filter(v => !Number.isNaN(v));
            let trimmed = String(val).trim();
            if (!trimmed) return [];
            // strip wrapping quotes if present
            if (trimmed.startsWith('"') && trimmed.endsWith('"')) {
                trimmed = trimmed.slice(1, -1);
            }
            // JSON/list style "[1.0, 2.0, 3.0]"
            if (trimmed.startsWith('[') && trimmed.endsWith(']')) {
                try {
                    return JSON.parse(trimmed).map(Number).filter(v => !Number.isNaN(v));
                } catch (e) {
                    // fall through to semicolon parsing
                }
            }
            // semicolon-separated "1.0;2.0;3.0"
            return trimmed.split(';')
                .map(x => parseFloat(x))
                .filter(v => !Number.isNaN(v));
        };

        const CSV_PATH = 'vocal_notes_stats.csv';
        const AUDIO_EXTENSION = '.wav';   // change to '.mp3' / '.m4a' if needed

        let allData = [];
        let chartInstance = null;
        let animationId = null;
        let dataTimeMin = 0;
        let dataTimeMax = 0;
        const PLAYBACK_WINDOW = 4.0;  // seconds around playhead
        let isDraggingPlayhead = false;
        const PLAYHEAD_LABEL = 'Playhead';

        function hzToMidi(freq) {
            return 69 + 12 * Math.log2(freq / 440.0);
        }

        function midiToNoteName(midi) {
            const names = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const m = Math.round(midi);
            const name = names[m % 12];
            const octave = Math.floor(m / 12) - 1;
            return `${name}${octave}`;
        }

        function splitCsvLine(line) {
            // Keeps bracketed arrays and quoted strings together as one field
            const regex = /\"[^\"]*\"|\[[^\]]*\]|[^,]+/g;
            const matches = line.match(regex);
            return matches ? matches.map(s => s.trim()) : [];
        }

        async function loadCSV(path) {
            const resp = await fetch(path);
            const text = await resp.text();

            const lines = text.trim().split(/\r?\n/);
            const header = lines[0].split(',');

            return lines.slice(1).map(line => {
                const cols = splitCsvLine(line);
                if (cols.length !== header.length) {
                    console.warn('CSV row length mismatch', { line, cols, expected: header.length });
                }
                const obj = {};
                header.forEach((h, i) => {
                    obj[h] = cols[i];
                });
                obj.note_index = parseInt(obj.note_index, 10);
                obj.start_time = parseFloat(obj.start_time);
                obj.end_time = parseFloat(obj.end_time);
                obj.duration = parseFloat(obj.duration);
                obj.measured_hz = parseFloat(obj.measured_hz);
                obj.target_hz = parseFloat(obj.target_hz);
                obj.cents_error = parseFloat(obj.cents_error);
                obj.midi = hzToMidi(obj.measured_hz);
                obj.frame_times = parseFloatArray(obj.frame_times || '');
                obj.frame_hz = parseFloatArray(obj.frame_hz || '');
                return obj;
            });
        }

        function populateTakeSelect(data) {
            const select = document.getElementById('takeSelect');
            const takes = Array.from(new Set(data.map(d => d.take))).sort();

            select.innerHTML = '';
            select.insertAdjacentHTML(
                'beforeend',
                `<option value="">Select a take…</option>`
            );

            takes.forEach(t => {
                select.insertAdjacentHTML(
                    'beforeend',
                    `<option value="${t}">${t}</option>`
                );
            });
        }

        function computeStats(rows) {
            if (!rows.length) return null;
            const cents = rows.map(r => r.cents_error);
            const absCents = cents.map(c => Math.abs(c));

            const avgSigned = cents.reduce((a, c) => a + c, 0) / cents.length;
            const avgAbs = absCents.reduce((a, c) => a + c, 0) / absCents.length;

            const mean = avgSigned;
            const variance = cents.reduce((acc, c) => acc + Math.pow(c - mean, 2), 0) / cents.length;
            const stdDev = Math.sqrt(variance);

            return { avgSigned, avgAbs, stdDev, count: cents.length };
        }

        function updateSummary(stats, takeName) {
            const el = document.getElementById('summary');
            const countEl = document.getElementById('noteCount');

            if (!stats) {
                el.textContent = 'No notes for this take.';
                countEl.textContent = '';
                return;
            }

            const biasLabel =
                stats.avgSigned < -1 ? ' (tends flat)' :
                    stats.avgSigned > 1 ? ' (tends sharp)' :
                        ' (roughly centered)';

            el.innerHTML =
                `<strong>${takeName}</strong><br>` +
                `Average absolute error: ${stats.avgAbs.toFixed(2)} cents<br>` +
                `Average signed error: ${stats.avgSigned.toFixed(2)} cents${biasLabel}<br>` +
                `Spread (std dev): ${stats.stdDev.toFixed(2)} cents`;

            countEl.textContent = `Notes: ${stats.count}`;
        }

        function colorForCents(absCents, maxAbs) {
            const clamped = Math.min(absCents / maxAbs, 1.0);
            const hue = 120 - 120 * clamped; // 120=green, 0=red
            return `hsl(${hue}, 100%, 50%)`;
        }

        function plotTake(rows, takeName) {
            const ctx = document.getElementById('timelineChart').getContext('2d');

            const maxAbs = rows.reduce(
                (m, r) => Math.max(m, Math.abs(r.cents_error)),
                1
            );

            // Line data: horizontal segments per note (start -> end)
            const lineData = [];
            const curveData = [];
            rows.forEach(r => {
                // skip totally zero-length notes if you want:
                // if (r.duration <= 0) return;

                lineData.push({
                    x: r.start_time,
                    y: r.midi,
                    cents: r.cents_error,
                    note: r.note_name,
                    start: r.start_time,
                    end: r.end_time
                });
                lineData.push({
                    x: r.end_time,
                    y: r.midi,
                    cents: r.cents_error,
                    note: r.note_name,
                    start: r.start_time,
                    end: r.end_time
                });
                // NaN break so Chart.js stops connecting to next note
                lineData.push({ x: NaN, y: NaN });

                // Frame-level contour for curvy performance line
                if (Array.isArray(r.frame_times) && Array.isArray(r.frame_hz) && r.frame_times.length) {
                    for (let i = 0; i < r.frame_times.length; i++) {
                        const ft = r.frame_times[i];
                        const fhz = r.frame_hz[i];
                        if (!Number.isFinite(ft) || !Number.isFinite(fhz)) continue;
                        curveData.push({
                            x: ft,
                            y: hzToMidi(fhz)
                        });
                    }
                    // break between notes
                    curveData.push({ x: NaN, y: NaN });
                }
            });

            // Center points for tooltips
            const centerData = rows.map(r => ({
                x: (r.start_time + r.end_time) / 2.0,
                y: r.midi,
                cents: r.cents_error,
                note: r.note_name,
                start: r.start_time,
                end: r.end_time
            }));

            const midiValues = rows.map(r => r.midi);
            const curveMidi = curveData.filter(p => Number.isFinite(p.y)).map(p => p.y);
            const allMidi = midiValues.concat(curveMidi);
            const minMidi = Math.min(...allMidi) - 1;
            const maxMidi = Math.max(...allMidi) + 1;

            dataTimeMin = Math.min(...rows.map(r => r.start_time));
            dataTimeMax = Math.max(...rows.map(r => r.end_time));

            if (chartInstance) {
                chartInstance.destroy();
            }

            chartInstance = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            // sustained note bars
                            label: 'Notes',
                            type: 'scatter',
                            data: lineData,
                            showLine: true,
                            pointRadius: 0,
                            borderWidth: 4,
                            segment: {
                                borderColor: ctx => {
                                    if (!ctx.p0 || !ctx.p0.raw || isNaN(ctx.p0.raw.x)) return 'transparent';
                                    const v = Math.abs(ctx.p0.raw.cents || 0);
                                    return colorForCents(v, maxAbs);
                                }
                            },
                            tooltip: { enabled: false } // tooltips handled by center dataset
                        },
                        {
                            // center dots for hover info
                            label: 'Pitch centers',
                            type: 'scatter',
                            data: centerData,
                            pointRadius: 4,
                            pointHoverRadius: 6,
                            pointBackgroundColor: ctx => {
                                const v = Math.abs(ctx.raw.cents);
                                return colorForCents(v, maxAbs);
                            }
                        },
                        {
                            // curvy performance line (frame-by-frame)
                            label: 'Performance curve',
                            type: 'scatter',
                            data: curveData,
                            showLine: true,
                            borderColor: 'rgba(94, 234, 212, 0.8)',
                            backgroundColor: 'rgba(94, 234, 212, 0.2)',
                            borderWidth: 1.5,
                            fill: false,
                            tension: 0.35,
                            pointRadius: 0,
                            spanGaps: false,
                            tooltip: {
                                callbacks: {
                                    label: (ctx) => {
                                        const t = ctx.raw.x;
                                        const midi = ctx.raw.y;
                                        return `Time: ${t.toFixed(2)} s  Pitch: ${midiToNoteName(midi)} (${midi.toFixed(2)} MIDI)`;
                                    }
                                }
                            }
                        },
                        {
                            // playhead line
                            label: PLAYHEAD_LABEL,
                            type: 'scatter',
                            data: [
                                { x: dataTimeMin, y: minMidi },
                                { x: dataTimeMin, y: maxMidi }
                            ],
                            showLine: true,
                            borderColor: 'rgba(255,255,255,0.9)',
                            borderWidth: 1.5,
                            pointRadius: 0,
                            hitRadius: 0,
                            hoverRadius: 0,
                            tooltip: { enabled: false }
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#eee' }
                        },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => {
                                    const r = ctx.raw;
                                    if (!r || r.note === undefined) return '';
                                    return [
                                        `${r.note}  (${r.cents.toFixed(2)} cents)`,
                                        `Time: ${r.start.toFixed(2)}–${r.end.toFixed(2)} s`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            min: dataTimeMin,
                            max: dataTimeMin + PLAYBACK_WINDOW,
                            title: {
                                display: true,
                                text: 'Time (s)',
                                color: '#eee'
                            },
                            ticks: { color: '#ccc' },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        },
                        y: {
                            type: 'linear',
                            min: minMidi,
                            max: maxMidi,
                            title: {
                                display: true,
                                text: 'Pitch (note lanes)',
                                color: '#eee'
                            },
                            ticks: {
                                stepSize: 1,
                                autoSkip: false,        // <-- show every semitone
                                color: '#ccc',
                                callback: value => midiToNoteName(value)
                            },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        }
                    }
                }
            });
        }

        function attachAudioHandlers() {
            const audio = document.getElementById('audioPlayer');
            const canvas = document.getElementById('timelineChart');

            const getPlayheadDataset = () => {
                if (!chartInstance) return null;
                return chartInstance.data.datasets.find(ds => ds.label === PLAYHEAD_LABEL) || null;
            };

            function cancelAnimation() {
                if (animationId !== null) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
            }

            function applyPlayhead(t) {
                if (!chartInstance) return;
                const ds = getPlayheadDataset();
                if (!ds) return;
                const yMin = chartInstance.options.scales.y.min;
                const yMax = chartInstance.options.scales.y.max;

                ds.data[0].x = t;
                ds.data[0].y = yMin;
                ds.data[1].x = t;
                ds.data[1].y = yMax;

                const halfWin = PLAYBACK_WINDOW / 2;
                let minX = t - halfWin;
                let maxX = t + halfWin;
                if (minX < dataTimeMin) {
                    minX = dataTimeMin;
                    maxX = minX + PLAYBACK_WINDOW;
                }
                if (maxX > dataTimeMax) {
                    maxX = dataTimeMax;
                    minX = maxX - PLAYBACK_WINDOW;
                }
                chartInstance.options.scales.x.min = minX;
                chartInstance.options.scales.x.max = maxX;

                chartInstance.update('none');
            }

            function updatePlayhead() {
                if (!chartInstance) return;

                const t = audio.currentTime;
                applyPlayhead(t);
                animationId = requestAnimationFrame(updatePlayhead);
            }

            audio.addEventListener('play', () => {
                cancelAnimation();
                animationId = requestAnimationFrame(updatePlayhead);
            });
            audio.addEventListener('pause', cancelAnimation);
            audio.addEventListener('ended', cancelAnimation);
            audio.addEventListener('seeking', () => {
                if (chartInstance) applyPlayhead(audio.currentTime);
            });

            // Click/drag directly on playhead to scrub
            function pointerPosToTime(evt) {
                if (!chartInstance || !chartInstance.scales || !chartInstance.scales.x) return null;
                const rect = canvas.getBoundingClientRect();
                const x = evt.clientX - rect.left;
                return chartInstance.scales.x.getValueForPixel(x);
            }

            function pointerNearPlayhead(evt, thresholdPx = 12) {
                if (!chartInstance || !chartInstance.scales || !chartInstance.scales.x) return false;
                const rect = canvas.getBoundingClientRect();
                const x = evt.clientX - rect.left;
                const playheadX = chartInstance.scales.x.getPixelForValue(audio.currentTime);
                return Math.abs(x - playheadX) <= thresholdPx;
            }

            function clamp(val, min, max) {
                return Math.min(Math.max(val, min), max);
            }

            const stopDrag = (evt) => {
                if (isDraggingPlayhead) {
                    isDraggingPlayhead = false;
                    if (canvas && evt && evt.pointerId !== undefined) {
                        canvas.releasePointerCapture(evt.pointerId);
                    }
                }
            };

            if (canvas) {
                canvas.addEventListener('pointerdown', (evt) => {
                    if (!pointerNearPlayhead(evt)) return;
                    const t = pointerPosToTime(evt);
                    if (t === null || isNaN(t)) return;
                    isDraggingPlayhead = true;
                    canvas.setPointerCapture(evt.pointerId);
                    const clamped = clamp(t, dataTimeMin, dataTimeMax);
                    audio.currentTime = clamped;
                    applyPlayhead(clamped);
                });

                canvas.addEventListener('pointermove', (evt) => {
                    if (!isDraggingPlayhead) return;
                    const t = pointerPosToTime(evt);
                    if (t === null || isNaN(t)) return;
                    const clamped = clamp(t, dataTimeMin, dataTimeMax);
                    audio.currentTime = clamped;
                    applyPlayhead(clamped);
                });

                canvas.addEventListener('pointerup', stopDrag);
                canvas.addEventListener('pointercancel', stopDrag);
                canvas.addEventListener('pointerleave', stopDrag);
            }

            // Space bar toggles play/pause (skip when typing in inputs/textareas/contenteditable)
            document.addEventListener('keydown', (e) => {
                const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
                if (tag === 'input' || tag === 'textarea' || e.target.isContentEditable) return;
                if (e.code === 'Space' || e.key === ' ') {
                    e.preventDefault();
                    if (audio.paused) audio.play();
                    else audio.pause();
                }
            });
        }

        async function init() {
            try {
                allData = await loadCSV(CSV_PATH);
                populateTakeSelect(allData);
                attachAudioHandlers();

                const select = document.getElementById('takeSelect');
                const audio = document.getElementById('audioPlayer');

                select.addEventListener('change', () => {
                    const take = select.value;
                    if (!take) {
                        updateSummary(null, '');
                        if (chartInstance) chartInstance.destroy();
                        audio.removeAttribute('src');
                        audio.load();
                        return;
                    }

                    const rows = allData.filter(d => d.take === take);
                    const stats = computeStats(rows);
                    updateSummary(stats, take);
                    plotTake(rows, take);

                    const src = `${take}${AUDIO_EXTENSION}`;
                    audio.src = src;
                    audio.load();
                });

            } catch (err) {
                console.error(err);
                alert('Error loading CSV. Make sure vocal_notes_stats.csv is in the same folder as this HTML.');
            }
        }

        init();
    </script>
</body>

</html>
