<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Vocal Similarity Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root {
      --bg: #0d0d0f;
      --panel: #141417;
      --card: #1a1a1f;
      --text: #f5f5f5;
      --muted: #b3b3b7;
      --accent: #f97316;
      --accent2: #22c55e;
      --danger: #ef4444;
      --border: #2d2d34;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 20px;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    h1 { margin: 0 0 4px; font-size: 32px; font-weight: 800; letter-spacing: -0.02em; }
    p { margin: 0 0 12px; color: var(--muted); }
    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }
    .meta { display: flex; flex-wrap: wrap; gap: 8px; }
    .meta span {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 6px 8px;
      color: var(--muted);
      font-size: 0.9rem;
    }
    label { color: var(--muted); }
    select {
      background: var(--card);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 6px 10px;
    }
    .cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
      gap: 10px;
    }
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
    }
    .card h3 { margin: 0 0 4px; color: var(--muted); font-size: 0.9rem; }
    .card .value { font-size: 1.3rem; font-weight: 600; }
    #pitchWrapper { height: 420px; margin-top: 10px; }
    #barWrapper { height: 240px; margin-top: 10px; }
    #noteWrapper { height: 260px; margin-top: 10px; }
    .controls { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
    .controls button, .controls input[type="file"]::-webkit-file-upload-button {
      background: var(--card);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 12px;
      cursor: pointer;
      transition: border-color 0.15s ease, transform 0.1s ease;
    }
    .controls button:hover, .controls input[type="file"]::-webkit-file-upload-button:hover {
      border-color: var(--accent);
      transform: translateY(-1px);
    }
    canvas {
      background: #18181c;
      border-radius: 12px;
      padding: 8px;
    }
    .player {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 10px 14px;
    }
    .player-meta { margin-top: 8px; color: var(--muted); font-size: 0.9rem; }
    .play-btn {
      background: var(--accent);
      color: #0a0a0a;
      border: none;
      border-radius: 999px;
      width: 42px;
      height: 42px;
      font-weight: 700;
      cursor: pointer;
      transition: transform 0.1s ease;
    }
    .play-btn:hover { transform: scale(1.05); }
    .seek {
      flex: 1;
      min-width: 180px;
      accent-color: var(--accent);
    }
    .time { min-width: 110px; text-align: right; color: var(--muted); }
    .toggles { display: flex; gap: 12px; color: var(--muted); font-size: 0.95rem; }
    .table { width: 100%; overflow-x: auto; }
    .table table { width: 100%; border-collapse: collapse; }
    .table th, .table td { padding: 8px 10px; border-bottom: 1px solid var(--border); text-align: left; }
    .table th { color: #fff; font-weight: 600; }
  </style>
</head>
<body>
  <h1>Vocal Similarity Dashboard</h1>
  <p>Loads <code>analysis_similarity.json</code> (or drop/select other JSONs). Shows reference vs vocal MIDI over time and cents/percent error on hover.</p>

  <div class="panel">
    <div class="controls">
      <button id="loadDefault">Load analysis_similarity.json</button>
      <label>
        Load JSON(s):
        <input type="file" id="fileInput" multiple accept=".json">
      </label>
    </div>
    <div class="meta" id="meta"></div>
  </div>

  <div class="panel">
    <h2>Playback</h2>
    <div class="player">
      <button class="play-btn" id="playPause" aria-label="Play/Pause">▶</button>
      <div class="toggles">
        <label><input type="checkbox" id="vocalToggle" checked> Vocal</label>
        <label><input type="checkbox" id="refToggle" checked> Reference</label>
      </div>
      <input type="range" id="seek" min="0" max="1" value="0" step="0.001" class="seek">
      <div class="time" id="timeLabel">0:00 / 0:00</div>
    </div>
    <div class="player-meta" id="playerMeta"></div>
  </div>

  <div class="panel">
    <h2>Summary</h2>
    <div class="cards" id="cards"></div>
  </div>

  <div class="panel">
    <h2>Pitch & Cents</h2>
    <div id="pitchWrapper"><canvas id="pitchChart"></canvas></div>
  </div>

  <div class="panel">
    <h2>Runs (Mean Abs Cents)</h2>
    <div id="barWrapper"><canvas id="barChart"></canvas></div>
  </div>

  <div class="panel">
    <h2>Per-Note Cents Error</h2>
    <div id="noteWrapper"><canvas id="noteChart"></canvas></div>
  </div>

  <script>
    let pitchChart, barChart, noteChart;
    const runs = []; // store {label, meanAbsCents}

    const audioEls = {
      vocal: new Audio(),
      ref: new Audio()
    };
    audioEls.vocal.preload = "auto";
    audioEls.ref.preload = "auto";
    let playheadTime = 0;
    let combinedDuration = 0;
    let rafId = null;
    let lastMetaDurations = { vocal: null, ref: null };
    let lastBaseUrl = window.location.href;
    let isPlaying = false;
    let isScrubbing = false;

    const midiToNote = (m) => {
      if (m === null || m === undefined || Number.isNaN(m)) return "—";
      const names = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
      const n = Math.round(m);
      return `${names[n % 12]}${Math.floor(n/12) - 1}`;
    };

    const fmt = (v, d=2) => (v === null || v === undefined || Number.isNaN(v)) ? "—" : Number(v).toFixed(d);
    const secondsLabel = (t) => {
      if (!Number.isFinite(t)) return "0:00";
      const m = Math.floor(t / 60);
      const s = Math.floor(t % 60).toString().padStart(2, "0");
      return `${m}:${s}`;
    };

    const playheadPlugin = {
      id: "playheadLine",
      afterDatasetsDraw(chart) {
        if (!Number.isFinite(playheadTime) || !chart?.scales?.x) return;
        const xScale = chart.scales.x;
        const x = xScale.getPixelForValue(playheadTime);
        if (Number.isNaN(x)) return;
        const ctx = chart.ctx;
        ctx.save();
        ctx.strokeStyle = "rgba(255,255,255,0.8)";
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(x, chart.chartArea.top);
        ctx.lineTo(x, chart.chartArea.bottom);
        ctx.stroke();
        ctx.restore();
      }
    };
    Chart.register(playheadPlugin);

    async function loadJsonFile(fileOrPath) {
      if (typeof fileOrPath === "string") {
        const url = new URL(fileOrPath, window.location.href);
        const resp = await fetch(url);
        if (!resp.ok) throw new Error("fetch failed");
        const data = await resp.json();
        const baseUrl = url.href.slice(0, url.href.lastIndexOf("/") + 1);
        return { data, baseUrl };
      } else {
        const data = JSON.parse(await fileOrPath.text());
        return { data, baseUrl: window.location.href };
      }
    }

    function renderMeta(meta={}) {
      const el = document.getElementById("meta");
      const parts = [];
      if (meta.vocal_path) parts.push(`Vocal: ${meta.vocal_path}`);
      if (meta.reference_path) parts.push(`Reference: ${meta.reference_path}`);
      if (meta.sample_rate) parts.push(`SR: ${meta.sample_rate} Hz`);
      if (meta.duration_vocal) parts.push(`Vocal dur: ${fmt(meta.duration_vocal,2)} s`);
      if (meta.duration_reference) parts.push(`Ref dur: ${fmt(meta.duration_reference,2)} s`);
      el.innerHTML = parts.map(p => `<span>${p}</span>`).join("");
    }

    function renderCards(summary={}) {
      const cardsEl = document.getElementById("cards");
      const cards = [
        { title: "Mean Abs Cents", value: fmt(summary.mean_abs_cents,1)+" c", color: "var(--accent)" },
        { title: "Within ±25c", value: fmt(summary.pct_within_25,1)+"%", color: "var(--accent2)" },
        { title: "Within ±50c", value: fmt(summary.pct_within_50,1)+"%", color: "var(--accent2)" },
        { title: "Within ±100c", value: fmt(summary.pct_within_100,1)+"%", color: "var(--accent2)" },
        { title: "Valid Frames", value: summary.valid_frames ?? 0, color: "var(--muted)" },
      ];
      cardsEl.innerHTML = cards.map(c => `
        <div class="card">
          <h3>${c.title}</h3>
          <div class="value" style="color:${c.color}">${c.value}</div>
        </div>
      `).join("");
    }

    function resolveAudioUrl(path, baseUrl) {
      if (!path) return "";
      try {
        return new URL(path, baseUrl || lastBaseUrl || window.location.href).href;
      } catch (e) {
        return path;
      }
    }

    function updatePlayerMeta(meta={}) {
      const el = document.getElementById("playerMeta");
      const parts = [];
      if (meta.vocal_path) parts.push(`Vocal: ${meta.vocal_path}`);
      if (meta.reference_path) parts.push(`Reference: ${meta.reference_path}`);
      el.textContent = parts.join(" • ");
    }

    function refreshDuration() {
      const durations = [
        audioEls.vocal.duration,
        audioEls.ref.duration,
        lastMetaDurations.vocal,
        lastMetaDurations.ref
      ].filter(Number.isFinite);
      combinedDuration = durations.length ? Math.max(...durations) : 0;
      const seek = document.getElementById("seek");
      seek.max = combinedDuration || 1;
      seek.step = "0.001";
      updateTimeLabel();
    }

    function setPlayhead(time, updateSlider=true) {
      playheadTime = Math.max(0, Math.min(time, combinedDuration || time));
      if (updateSlider) {
        document.getElementById("seek").value = playheadTime;
      }
      updateTimeLabel(playheadTime);
      if (pitchChart) pitchChart.draw();
    }

    function updateTimeLabel(current = playheadTime) {
      const total = combinedDuration || 0;
      document.getElementById("timeLabel").textContent = `${secondsLabel(current)} / ${secondsLabel(total)}`;
    }

    function syncCurrentTime(time) {
      ["vocal","ref"].forEach(key => {
        const a = audioEls[key];
        if (!a || !a.src) return;
        if (Math.abs((a.currentTime || 0) - time) > 0.03) {
          a.currentTime = Math.min(time, a.duration || combinedDuration || time);
        }
      });
    }

    function audioEnabled(key) {
      return document.getElementById(`${key}Toggle`).checked && !!audioEls[key].src;
    }

    function applyPlayState(play) {
      const shouldPlay = play ?? !isPlaying;
      isPlaying = shouldPlay && (audioEnabled("vocal") || audioEnabled("ref"));
      syncCurrentTime(playheadTime);
      ["vocal","ref"].forEach(key => {
        const a = audioEls[key];
        if (!a || !a.src) return;
        if (audioEnabled(key) && isPlaying) {
          a.play().catch(()=>{});
        } else {
          a.pause();
        }
      });
      document.getElementById("playPause").textContent = isPlaying ? "❚❚" : "▶";
      tickPlayhead();
    }

    function tickPlayhead() {
      if (rafId) cancelAnimationFrame(rafId);
      if (!isPlaying) return;
      const step = () => {
        const master = audioEnabled("vocal") ? audioEls.vocal : audioEnabled("ref") ? audioEls.ref : null;
        const t = master ? master.currentTime : playheadTime;
        setPlayhead(t);
        if (audioEnabled("vocal") && audioEnabled("ref")) {
          if (Math.abs(audioEls.vocal.currentTime - audioEls.ref.currentTime) > 0.05) {
            audioEls.ref.currentTime = audioEls.vocal.currentTime;
          }
        }
        if (isPlaying) rafId = requestAnimationFrame(step);
      };
      rafId = requestAnimationFrame(step);
    }

    function attachAudioEvents() {
      ["vocal","ref"].forEach(key => {
        audioEls[key].addEventListener("loadedmetadata", refreshDuration);
        audioEls[key].addEventListener("timeupdate", () => {
          if (isScrubbing) return;
          setPlayhead(audioEls[key].currentTime);
          if (audioEnabled("vocal") && audioEnabled("ref")) {
            if (Math.abs(audioEls.vocal.currentTime - audioEls.ref.currentTime) > 0.05) {
              audioEls.ref.currentTime = audioEls.vocal.currentTime;
            }
          }
        });
        audioEls[key].addEventListener("play", () => { isPlaying = true; tickPlayhead(); });
        audioEls[key].addEventListener("ended", () => {
          if (audioEnabled("vocal") && !audioEls.vocal.paused) return;
          if (audioEnabled("ref") && !audioEls.ref.paused) return;
          isPlaying = false;
          document.getElementById("playPause").textContent = "▶";
        });
      });
    }

    attachAudioEvents();

    function setAudioSources(meta={}, baseUrl) {
      lastBaseUrl = baseUrl || lastBaseUrl || window.location.href;
      lastMetaDurations = {
        vocal: Number.isFinite(meta.duration_vocal) ? meta.duration_vocal : null,
        ref: Number.isFinite(meta.duration_reference) ? meta.duration_reference : null
      };
      const vocalSrc = resolveAudioUrl(meta.vocal_path, baseUrl);
      const refSrc = resolveAudioUrl(meta.reference_path, baseUrl);
      audioEls.vocal.src = vocalSrc;
      audioEls.ref.src = refSrc;
      if (vocalSrc) audioEls.vocal.load();
      if (refSrc) audioEls.ref.load();
      setPlayhead(0);
      refreshDuration();
      updatePlayerMeta(meta);
    }
    function renderPitchChart(frames=[]) {
      const ctx = document.getElementById("pitchChart").getContext("2d");
      const times = frames.map(f => f.time);
      const vocalMidi = frames.map(f => f.vocal_midi ?? null);
      const refMidi = frames.map(f => f.ref_midi ?? null);

      if (pitchChart) pitchChart.destroy();
      pitchChart = new Chart(ctx, {
        type: "line",
        data: {
          labels: times,
          datasets: [
            {
              label: "Vocal (MIDI)",
              data: vocalMidi,
              borderColor: "rgba(56, 189, 248, 0.9)",
              backgroundColor: "rgba(56, 189, 248, 0.2)",
              borderWidth: 2,
              pointRadius: 0,
              spanGaps: false,
              yAxisID: "y",
            },
            {
              label: "Reference (MIDI)",
              data: refMidi,
              borderColor: "rgba(34, 197, 94, 0.9)",
              backgroundColor: "rgba(34, 197, 94, 0.2)",
              borderWidth: 2,
              pointRadius: 0,
              spanGaps: false,
              yAxisID: "y",
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { mode: "index", intersect: false },
          plugins: {
            legend: { labels: { color: "#fff" } }
          },
          scales: {
            y: {
              type: "linear",
              position: "left",
              title: { display: true, text: "MIDI" },
              ticks: { color: "#fff" },
              grid: { color: "rgba(255,255,255,0.08)" }
            },
            x: {
              title: { display: true, text: "Time (s)" },
              ticks: { color: "#fff" },
              grid: { color: "rgba(255,255,255,0.05)" }
            }
          }
        }
      });
    }

    function renderBars() {
      const ctx = document.getElementById("barChart").getContext("2d");
      if (barChart) barChart.destroy();
      barChart = new Chart(ctx, {
        type: "bar",
        data: {
          labels: runs.map(r => r.label),
          datasets: [{
            label: "Mean Abs Cents",
            data: runs.map(r => r.meanAbsCents),
            backgroundColor: "rgba(56, 189, 248, 0.6)",
            borderColor: "rgba(56, 189, 248, 1)",
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: { ticks: { color: "#fff" }, grid: { color: "rgba(255,255,255,0.05)" } },
            y: { ticks: { color: "#fff" }, grid: { color: "rgba(255,255,255,0.08)" }, title: { display: true, text: "Cents", color: "#fff" } }
          },
          plugins: { legend: { labels: { color: "#fff" } } }
        }
      });
    }

    function renderNoteStats(frames=[]) {
      const tableEl = document.getElementById("noteTable");
      if (!frames.length) {
        tableEl.textContent = "No data.";
        return;
      }
      const groups = {};
      frames.forEach(f => {
        if (f.ref_midi == null || f.cents_error == null) return;
        const key = Math.round(f.ref_midi);
        if (!groups[key]) groups[key] = { midi: key, note: midiToNote(key), vals: [] };
        groups[key].vals.push(f.cents_error);
      });
      const rows = Object.values(groups).map(g => {
        const mean = g.vals.reduce((a,c)=>a+c,0)/g.vals.length;
        const meanAbs = g.vals.reduce((a,c)=>a+Math.abs(c),0)/g.vals.length;
        return { midi: g.midi, note: g.note, count: g.vals.length, mean, meanAbs };
      }).sort((a,b)=>a.midi - b.midi);

      tableEl.innerHTML = `
        <table>
          <thead><tr><th>Note</th><th>Frames</th><th>Mean Cents</th><th>Mean |Cents|</th></tr></thead>
          <tbody>
            ${rows.map(r => `<tr>
              <td>${r.note}</td>
              <td>${r.count}</td>
              <td>${fmt(r.mean,1)}</td>
              <td>${fmt(r.meanAbs,1)}</td>
            </tr>`).join("")}
          </tbody>
        </table>
      `;
    }

    function labelForMeta(meta) {
      const base = meta && meta.vocal_path ? meta.vocal_path.split("/").pop() : "run";
      const ref = meta && meta.reference_path ? meta.reference_path.split("/").pop() : "";
      return ref ? `${base} vs ${ref}` : base;
    }

    async function handleDataLoad(data, baseUrl) {
      renderMeta(data.metadata || {});
      renderCards(data.summary || {});
      renderPitchChart(data.frames || []);
      renderNoteStats(data.frames || []);
      setAudioSources(data.metadata || {}, baseUrl);
      // track run for bar chart
      if (data.summary && data.summary.mean_abs_cents !== undefined) {
        runs.push({
          label: labelForMeta(data.metadata || {}),
          meanAbsCents: data.summary.mean_abs_cents
        });
        renderBars();
      }
    }

    document.getElementById("loadDefault").addEventListener("click", async () => {
      try {
        const { data, baseUrl } = await loadJsonFile("analysis_similarity.json");
        await handleDataLoad(data, baseUrl);
      } catch (e) {
        alert("Could not load analysis_similarity.json");
        console.error(e);
      }
    });

    document.getElementById("fileInput").addEventListener("change", async (e) => {
      const files = Array.from(e.target.files || []);
      for (const f of files) {
        try {
          const { data, baseUrl } = await loadJsonFile(f);
          await handleDataLoad(data, baseUrl);
        } catch (err) {
          console.error("Failed to load file", f.name, err);
        }
      }
    });

    document.getElementById("playPause").addEventListener("click", () => applyPlayState(!isPlaying));
    document.getElementById("seek").addEventListener("input", (e) => {
      const t = Number(e.target.value);
      setPlayhead(t, false);
      syncCurrentTime(t);
    });
    document.getElementById("seek").addEventListener("pointerdown", () => { isScrubbing = true; });
    document.getElementById("seek").addEventListener("pointerup", () => { isScrubbing = false; syncCurrentTime(playheadTime); });
    document.getElementById("vocalToggle").addEventListener("change", () => applyPlayState(isPlaying));
    document.getElementById("refToggle").addEventListener("change", () => applyPlayState(isPlaying));

    // Auto-load default if available
    (async () => {
      try {
        const { data, baseUrl } = await loadJsonFile("analysis_similarity.json");
        await handleDataLoad(data, baseUrl);
      } catch (e) {
        console.info("analysis_similarity.json not auto-loaded:", e);
      }
    })();
  </script>
</body>
</html>
