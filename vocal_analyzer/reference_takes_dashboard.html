<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Reference Takes Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root {
      --bg: #0d0d0f;
      --panel: #141417;
      --card: #1a1a1f;
      --text: #f5f5f5;
      --muted: #b3b3b7;
      --accent: #f97316;
      --accent2: #22c55e;
      --border: #2d2d34;
    }
    * { box-sizing: border-box; }
    body { margin: 0; padding: 18px; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; }
    h1 { margin: 0 0 6px; font-size: 30px; }
    p { margin: 0 0 12px; color: var(--muted); }
    .panel { background: var(--panel); border: 1px solid var(--border); border-radius: 12px; padding: 14px; margin-bottom: 12px; box-shadow: 0 8px 22px rgba(0,0,0,0.35); }
    .controls { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    select { background: var(--card); color: var(--text); border: 1px solid var(--border); border-radius: 8px; padding: 6px 10px; }
    .player { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; background: var(--card); border:1px solid var(--border); border-radius: 12px; padding: 10px; }
    .play-btn { background: var(--accent); border: none; color: #0a0a0a; border-radius: 10px; padding: 10px 12px; font-weight: 700; cursor: pointer; }
    .toggles { display: flex; gap: 10px; color: var(--muted); }
    .seek { flex: 1; min-width: 180px; accent-color: var(--accent); }
    .time { color: var(--muted); min-width: 110px; text-align: right; }
    #chartWrapper { height: 420px; margin-top: 10px; }
    canvas { background: #18181c; border-radius: 12px; padding: 8px; }
    .cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px,1fr)); gap: 10px; }
    .card { background: var(--card); border:1px solid var(--border); border-radius: 10px; padding: 10px; }
    .card h3 { margin:0 0 4px; color: var(--muted); font-size: 0.9rem; }
    .card .value { font-size: 1.2rem; font-weight: 700; }
    #scoresWrapper { height: 260px; }
  </style>
</head>
<body>
  <h1>Reference Takes Dashboard</h1>
  <p>Compare recorded takes against a reference audio. Select a take, play both tracks together or solo, and view melody vs reference with a shared playhead.</p>

  <div class="panel">
    <div class="controls">
      <label>Take:
        <select id="takeSelect"><option>Loading…</option></select>
      </label>
      <button id="reload">Reload data</button>
    </div>
    <div class="player">
      <button class="play-btn" id="playPause">▶</button>
      <div class="toggles">
        <label><input type="checkbox" id="vocalToggle" checked> Vocal</label>
        <label><input type="checkbox" id="refToggle" checked> Reference</label>
      </div>
      <input type="range" id="seek" class="seek" min="0" max="1" step="0.001" value="0">
      <div class="time" id="timeLabel">0:00 / 0:00</div>
    </div>
  </div>

  <div class="panel">
    <div class="cards" id="cards"></div>
    <div id="chartWrapper"><canvas id="melodyChart"></canvas></div>
  </div>

  <div class="panel">
    <h3>Take Scores</h3>
    <div id="scoresWrapper"><canvas id="scoresChart"></canvas></div>
  </div>

  <script>
    const DATA_URL = "analysis_similarity.json";
    let runs = [];
    let selected = null;
    let melodyChart = null;
    let scoresChart = null;
    const audioEls = { vocal: new Audio(), ref: new Audio() };
    let isPlaying = false;
    let playheadTime = 0;
    let duration = 0;
    let zoomWindow = 4;

    const playheadPlugin = {
      id: 'playhead',
      afterDatasetsDraw(chart) {
        if (!Number.isFinite(playheadTime)) return;
        const xScale = chart.scales.x;
        if (!xScale) return;
        const x = xScale.getPixelForValue(playheadTime);
        if (Number.isNaN(x)) return;
        const ctx = chart.ctx;
        ctx.save();
        ctx.strokeStyle = 'rgba(255,255,255,0.9)';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(x, chart.chartArea.top);
        ctx.lineTo(x, chart.chartArea.bottom);
        ctx.stroke();
        ctx.restore();
      }
    };
    Chart.register(playheadPlugin);

    const fmt = (v,d=2)=> v==null||Number.isNaN(v) ? "—" : Number(v).toFixed(d);
    const fmtTime = (t)=> {
      if (!Number.isFinite(t)) return "0:00";
      const m=Math.floor(t/60), s=Math.floor(t%60).toString().padStart(2,"0");
      return `${m}:${s}`;
    };

    const resolveUrl = (path, base) => {
      if (!path) return "";
      // Normalize common relative prefixes to avoid double-folders
      if (path.startsWith("http://") || path.startsWith("https://")) return path;
      if (path.startsWith("vocal_analyzer/")) path = "/" + path; // treat as root-relative
      if (path.startsWith("./")) path = path.slice(2);
      try { return new URL(path, base || window.location.href).href; } catch { return path; }
    };

    function normalizeRuns(data, baseUrl) {
      const arr = data.runs || [];
      return arr.map(r => {
        const take =
          r.take ||
          (r.metadata && r.metadata.vocal_path && r.metadata.vocal_path.split("/").pop().replace(/\.[^.]+$/, "")) ||
          "take";
        return { ...r, take, baseUrl };
      });
    }

    async function loadData() {
      const resp = await fetch(`${DATA_URL}?ts=${Date.now()}`, { cache:'no-store' });
      if (!resp.ok) throw new Error("Could not load analysis_similarity.json");
      const data = await resp.json();
      const baseUrl = resp.url;
      runs = normalizeRuns(data, baseUrl);
      if (runs.length && !selected) selected = runs[0].take;
      renderTakeSelect();
      renderScores();
      renderTake(selected);
    }

    function renderTakeSelect() {
      const sel = document.getElementById("takeSelect");
      sel.innerHTML = runs.map((r,i) => `<option value="${r.take}">${r.take}</option>`).join("");
      if (selected) sel.value = selected;
      sel.onchange = () => {
        selected = sel.value;
        renderTake(selected);
        renderScores();
      };
    }

    function setAudioSources(run) {
      const meta = run.metadata || {};
      const base = run.baseUrl || window.location.href;
      audioEls.vocal.src = resolveUrl(meta.vocal_path, base);
      audioEls.ref.src = resolveUrl(meta.reference_path, base);
      audioEls.vocal.load(); audioEls.ref.load();
      duration = Math.max(meta.duration_vocal || 0, meta.duration_reference || 0, run.frames?.at(-1)?.time || 0);
      if (duration <= 0) duration = 1;
      playheadTime = 0;
      document.getElementById("seek").max = duration;
      document.getElementById("seek").value = 0;
      document.getElementById("timeLabel").textContent = `${fmtTime(0)} / ${fmtTime(duration)}`;
    }

    function togglePlay(play) {
      const shouldPlay = play ?? !isPlaying;
      isPlaying = shouldPlay && (audioEls.vocal.src || audioEls.ref.src);
      if (isPlaying) {
        if (document.getElementById("vocalToggle").checked) audioEls.vocal.play().catch(()=>{});
        if (document.getElementById("refToggle").checked) audioEls.ref.play().catch(()=>{});
      } else {
        audioEls.vocal.pause(); audioEls.ref.pause();
      }
      document.getElementById("playPause").textContent = isPlaying ? "❚❚" : "▶";
      requestAnimationFrame(updatePlayhead);
    }

    function updatePlayhead() {
      const master = document.getElementById("vocalToggle").checked ? audioEls.vocal : audioEls.ref;
      playheadTime = master.currentTime || 0;
      document.getElementById("seek").value = playheadTime;
      document.getElementById("timeLabel").textContent = `${fmtTime(playheadTime)} / ${fmtTime(duration)}`;
      if (melodyChart) melodyChart.update('none');
      if (isPlaying) requestAnimationFrame(updatePlayhead);
    }

    function renderCards(summary={}, takeName="") {
      const cards = [
        { title:"Take", value: takeName || "—", color:"var(--text)" },
        { title:"Mean Abs Cents", value: fmt(summary.mean_abs_cents,1)+" c", color:"var(--accent)" },
        { title:"Within ±25c", value: fmt(summary.pct_within_25,1)+"%", color:"var(--accent2)" },
        { title:"Within ±50c", value: fmt(summary.pct_within_50,1)+"%", color:"var(--accent2)" },
        { title:"Within ±100c", value: fmt(summary.pct_within_100,1)+"%", color:"var(--accent2)" },
        { title:"Valid Frames", value: summary.valid_frames ?? 0, color:"var(--muted)" },
      ];
      document.getElementById("cards").innerHTML = cards.map(c=>`
        <div class="card"><h3>${c.title}</h3><div class="value" style="color:${c.color}">${c.value}</div></div>
      `).join("");
    }

    function renderMelody(run) {
      const frames = run.frames || [];
      const vocalPoints = frames.map(f => ({ x: f.time, y: f.vocal_midi ?? null }));
      const refPoints = frames.map(f => ({ x: f.time, y: f.ref_midi ?? null }));
      const timeMin = Math.min(...frames.map(f=>f.time), 0);
      const timeMax = Math.max(...frames.map(f=>f.time), duration, 0);
      const ctx = document.getElementById("melodyChart").getContext("2d");
      if (melodyChart) melodyChart.destroy();
      melodyChart = new Chart(ctx, {
        type:"scatter",
        data:{
          datasets:[
            { label:"Vocal (MIDI)", data:vocalPoints, showLine:true, borderColor:"rgba(56,189,248,0.9)", backgroundColor:"rgba(56,189,248,0.2)", borderWidth:2, pointRadius:0, spanGaps:false, parsing:false, tension:0 },
            { label:"Reference (MIDI)", data:refPoints, showLine:true, borderColor:"rgba(34,197,94,0.9)", backgroundColor:"rgba(34,197,94,0.2)", borderWidth:2, pointRadius:0, spanGaps:false, parsing:false, tension:0 }
          ]
        },
        options:{
          responsive:true,
          maintainAspectRatio:false,
          interaction:{ mode:"index", intersect:false },
          plugins:{ legend:{ labels:{ color:"#fff" } } },
          scales:{
            x:{ title:{ display:true, text:"Time (s)" , color:"#fff"}, ticks:{ color:"#fff" }, grid:{ color:"rgba(255,255,255,0.05)" }, min: timeMin, max: timeMax },
            y:{ title:{ display:true, text:"MIDI", color:"#fff"}, ticks:{ color:"#fff" }, grid:{ color:"rgba(255,255,255,0.08)" } }
          }
        }
      });

      // Scrub by clicking/dragging on chart
      const scrub = (evt) => {
        const xVal = melodyChart.scales.x.getValueForPixel(evt.offsetX);
        if (!Number.isFinite(xVal)) return;
        const t = Math.max(0, Math.min(xVal, duration));
        playheadTime = t;
        audioEls.vocal.currentTime = t;
        audioEls.ref.currentTime = t;
        document.getElementById("seek").value = t;
        document.getElementById("timeLabel").textContent = `${fmtTime(t)} / ${fmtTime(duration)}`;
        melodyChart.update('none');
      };
      let dragging = false;
      melodyChart.canvas.onpointerdown = (e) => { dragging = true; scrub(e); };
      melodyChart.canvas.onpointermove = (e) => { if (dragging) scrub(e); };
      window.onpointerup = () => { dragging = false; };
    }

    function renderScores() {
      const labels = runs.map(r=>r.take);
      const scores = runs.map(r=>r.summary?.mean_abs_cents ?? null); // mean abs cents (original metric)
      const ctx = document.getElementById("scoresChart").getContext("2d");
      if (scoresChart) scoresChart.destroy();
      scoresChart = new Chart(ctx,{
        type:"bar",
        data:{ labels, datasets:[{ label:"Mean Abs Cents", data:scores, backgroundColor: labels.map(l=> l===selected ? "#f97316" : "#60a5fa") }]},
        options:{
          responsive:true,
          maintainAspectRatio:false,
          scales:{
            y:{ title:{ display:true, text:"Mean Abs Cents", color:"#fff" }, ticks:{ color:"#fff" }, grid:{ color:"rgba(255,255,255,0.08)" } },
            x:{ ticks:{ color:"#fff" }, grid:{ color:"rgba(255,255,255,0.05)" } }
          },
          plugins:{ legend:{ display:false } },
          onClick: (_, el)=>{ if (el?.length){ selected = labels[el[0].index]; renderTake(selected); renderScores(); } }
        }
      });
    }

    function renderTake(takeName) {
      const run = runs.find(r=>r.take===takeName);
      if (!run) return;
      selected = takeName;
      setAudioSources(run);
      renderCards(run.summary || {}, takeName);
      renderMelody(run);
    }

    document.getElementById("playPause").onclick = () => togglePlay();
    document.getElementById("seek").oninput = (e) => {
      const t = Number(e.target.value);
      playheadTime = t;
      audioEls.vocal.currentTime = t;
      audioEls.ref.currentTime = t;
      document.getElementById("timeLabel").textContent = `${fmtTime(t)} / ${fmtTime(duration)}`;
      if (melodyChart) melodyChart.update('none');
    };
    document.getElementById("vocalToggle").onchange = () => { if (!document.getElementById("vocalToggle").checked) audioEls.vocal.pause(); };
    document.getElementById("refToggle").onchange = () => { if (!document.getElementById("refToggle").checked) audioEls.ref.pause(); };
    document.getElementById("reload").onclick = loadData;

    audioEls.vocal.addEventListener("timeupdate", () => {
      if (!isPlaying) return;
      playheadTime = audioEls.vocal.currentTime;
    });
    audioEls.ref.addEventListener("timeupdate", () => {
      if (!isPlaying) return;
      // keep ref aligned to vocal if vocal is enabled
      if (document.getElementById("vocalToggle").checked) {
        const delta = Math.abs(audioEls.ref.currentTime - audioEls.vocal.currentTime);
        if (delta > 0.05) audioEls.ref.currentTime = audioEls.vocal.currentTime;
      }
    });

    // Auto-refresh every 15s to pick up new takes
    setInterval(loadData, 15000);
    loadData().catch(err => console.error(err));
  </script>
</body>
</html>
