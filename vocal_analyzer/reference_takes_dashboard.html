<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Reference Takes Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root {
      --bg: #0d0d0f;
      --panel: #141417;
      --card: #1a1a1f;
      --text: #f5f5f5;
      --muted: #b3b3b7;
      --accent: #f97316;
      --accent2: #22c55e;
      --border: #2d2d34;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 18px;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    h1 {
      margin: 0 0 6px;
      font-size: 30px;
    }

    p {
      margin: 0 0 12px;
      color: var(--muted);
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 14px;
      margin-bottom: 12px;
      box-shadow: 0 8px 22px rgba(0, 0, 0, 0.35);
    }

    .controls {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    select {
      background: var(--card);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 6px 10px;
    }

    .player {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px;
    }

    .play-btn {
      background: var(--accent);
      border: none;
      color: #0a0a0a;
      border-radius: 10px;
      padding: 10px 12px;
      font-weight: 700;
      cursor: pointer;
    }

    .toggles {
      display: flex;
      gap: 10px;
      color: var(--muted);
    }

    .seek {
      flex: 1;
      min-width: 180px;
      accent-color: var(--accent);
    }

    .time {
      color: var(--muted);
      min-width: 110px;
      text-align: right;
    }

    #chartWrapper {
      height: 420px;
      margin-top: 10px;
    }

    #volumeWrapper {
      height: 260px;
      margin-top: 10px;
    }

    #toneWrapper {
      height: 260px;
      margin-top: 10px;
    }

    #toneSpectralWrapper {
      height: 260px;
      margin-top: 10px;
    }

    #toneProfileWrapper {
      height: 260px;
      margin-top: 10px;
    }

    .tone-metrics {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
      gap: 10px;
      margin-top: 12px;
    }

    .tone-metric {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-height: 70px;
    }

    .tone-metric span {
      color: var(--muted);
      font-size: 0.95rem;
    }

    .tone-metric strong {
      color: var(--accent2);
      font-size: 1.1rem;
    }

    .tone-tips {
      margin-top: 12px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px;
      color: var(--muted);
      line-height: 1.5;
    }

    canvas {
      background: #18181c;
      border-radius: 12px;
      padding: 8px;
    }

    .cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 10px;
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px;
    }

    .card h3 {
      margin: 0 0 4px;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .card .value {
      font-size: 1.2rem;
      font-weight: 700;
    }

    #scoresWrapper {
      height: 260px;
    }
  </style>
</head>

<body>
  <h1>Reference Takes Dashboard</h1>
  <p>Compare recorded takes against a reference audio. Select a take, play both tracks together or solo, and view melody
    vs reference with a shared playhead.</p>

  <div class="panel">
    <div class="controls">
      <label>Take:
        <select id="takeSelect">
          <option>Loading…</option>
        </select>
      </label>
      <button id="reload">Reload data</button>
    </div>
    <div class="player">
      <button class="play-btn" id="playPause">▶</button>
      <div class="toggles">
        <label><input type="checkbox" id="vocalToggle" checked> Vocal</label>
        <label><input type="checkbox" id="refToggle" checked> Reference</label>
      </div>
      <input type="range" id="seek" class="seek" min="0" max="1" step="0.001" value="0">
      <div class="time" id="timeLabel">0:00 / 0:00</div>
    </div>
  </div>

  <div class="panel">
    <div class="cards" id="cards"></div>
    <div id="chartWrapper"><canvas id="melodyChart"></canvas></div>
  </div>

  <div class="panel">
    <h3>Volume (RMS)</h3>
    <div id="volumeWrapper"><canvas id="volumeChart"></canvas></div>
  </div>

  <div class="panel">
    <h3>Tone Smoothness</h3>
    <div id="toneWrapper"><canvas id="toneChart"></canvas></div>
  </div>

  <div class="panel">
    <h3>Tone Spectral</h3>
    <div id="toneSpectralWrapper"><canvas id="toneSpectralChart"></canvas></div>
  </div>

  <div class="panel">
    <h3>Tone Profile (Averages)</h3>
    <div id="toneProfileWrapper"><canvas id="toneProfileChart"></canvas></div>
    <div id="toneMetrics" class="tone-metrics"></div>
    <div id="toneTips" class="tone-tips"></div>
  </div>

  <div class="panel">
    <h3>Take Scores</h3>
    <div id="scoresWrapper"><canvas id="scoresChart"></canvas></div>
  </div>

  <script>
    const DATA_URL = "analysis_similarity.json";
    let runs = [];
    let selected = null;
    let melodyChart = null;
    let volumeChart = null;
    let toneChart = null;
    let toneSpectralChart = null;
    let toneProfileChart = null;
    let scoresChart = null;
    const audioEls = { vocal: new Audio(), ref: new Audio() };
    let isPlaying = false;
    let playheadTime = 0;
    let duration = 0;
    let zoomWindow = 4;

    const playheadPlugin = {
      id: 'playhead',
      afterDatasetsDraw(chart) {
        if (!Number.isFinite(playheadTime)) return;
        const xScale = chart.scales.x;
        if (!xScale) return;
        const x = xScale.getPixelForValue(playheadTime);
        if (Number.isNaN(x)) return;
        const ctx = chart.ctx;
        ctx.save();
        ctx.strokeStyle = 'rgba(255,255,255,0.9)';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(x, chart.chartArea.top);
        ctx.lineTo(x, chart.chartArea.bottom);
        ctx.stroke();
        ctx.restore();
      }
    };
    Chart.register(playheadPlugin);

    const fmt = (v, d = 2) => v == null || Number.isNaN(v) ? "—" : Number(v).toFixed(d);
    const fmtTime = (t) => {
      if (!Number.isFinite(t)) return "0:00";
      const m = Math.floor(t / 60), s = Math.floor(t % 60).toString().padStart(2, "0");
      return `${m}:${s}`;
    };

    const toneHelp = {
      "Brightness": {
        meaning: "Higher = more upper harmonics/energy (brighter). Lower = darker/warmer.",
        improve: "For brighter tone, sing with more forward resonance and open vowels; for darker, relax larynx and use rounder vowels."
      },
      "Noisiness": {
        meaning: "Higher = more noise-like (breathy/airy). Lower = cleaner, more pitched.",
        improve: "Reduce breathiness with firmer cord closure and steady airflow; for more air, lighten support and soften onset."
      },
      "Tilt (Warm→Bright)": {
        meaning: "1 = warm/low-heavy; 10 = bright/high-heavy spectrum.",
        improve: "Shift brightness with vowel tuning and resonance (more smile/forward for bright, more space/yawn for warm)."
      },
      "Clarity": {
        meaning: "Higher = clearer/more harmonic (higher HNR).",
        improve: "Use clean onsets and steady support; minimize harsh consonants during sustained vowels."
      },
      "Breathy→Pressed": {
        meaning: "1 = pressed; 10 = breathier phonation (via H1–H2).",
        improve: "If too pressed, ease subglottal pressure; if too breathy, firm up closure and focus resonance."
      },
      "Tone mean |Δ|": {
        meaning: "Average frame-to-frame pitch change (cents); lower = smoother tone line.",
        improve: "Sustain vowels steadily, lighten vibrato width, and reduce unnecessary pitch scoops."
      },
      "Tone median |Δ|": {
        meaning: "Median frame-to-frame pitch change; robust smoothness indicator.",
        improve: "Practice slow, even slides and controlled legato to stabilize pitch changes."
      },
      "Tone within ±20c": {
        meaning: "Percent of steps with small pitch change; higher = steadier contour.",
        improve: "Focus on consistent airflow and minimal jaw/tongue movement between notes."
      },
      "Jitter (mean)": {
        meaning: "Cycle-to-cycle pitch variation proxy; lower = steadier pitch cycles.",
        improve: "Relax tension, keep breath support steady, and aim for gentle onsets."
      },
      "Shimmer (mean)": {
        meaning: "Cycle-to-cycle amplitude variation proxy; lower = steadier loudness cycles.",
        improve: "Maintain even airflow and support; avoid sudden breath pulses."
      }
    };

    // --- New helper functions and scoring ---
    const clamp = (v, min, max) => Math.min(max, Math.max(min, v));
    const safePct = (v) => {
      if (v == null || Number.isNaN(v)) return null;
      return clamp(Number(v), 0, 100);
    };
    const smallIsGoodToPct = (v, goodMax) => {
      if (v == null || !Number.isFinite(v)) return null;
      const frac = clamp(v / goodMax, 0, 1);
      return (1 - frac) * 100;
    };
    function computeTakeScores(run) {
      const pitchSummary = run.summary || {};
      const volSummary = run.volume?.summary || {};
      const toneSummary = run.tone?.summary || {};
      const smooth = toneSummary.smoothness || {};
      const jitterBlock = toneSummary.jitter || {};
      const spectral = toneSummary.spectral || {};
      const cats = spectral.categories || {};
      const pitch = safePct(pitchSummary.pct_within_50);
      const vol = safePct(volSummary.pct_within_tolerance);
      const smoothPct = safePct(smooth.pct_within_tolerance);
      const jitterMean = jitterBlock.jitter?.mean;
      const shimmerMean = jitterBlock.shimmer?.mean;
      const jitterScore = smallIsGoodToPct(jitterMean, 0.05);
      const shimmerScore = smallIsGoodToPct(shimmerMean, 0.10);
      let toneStability = null;
      const toneParts = [jitterScore, shimmerScore].filter(v => v != null);
      if (toneParts.length) {
        toneStability = toneParts.reduce((a, b) => a + b, 0) / toneParts.length;
      }
      const clarityCat = cats.clarity?.score;
      const clarity = clarityCat == null ? null : clamp((Number(clarityCat) / 10) * 100, 0, 100);
      const parts = [];
      const addPart = (score, weight) => {
        if (score == null || !Number.isFinite(score)) return;
        parts.push({ score, weight });
      };
      addPart(pitch, 0.5);
      addPart(vol, 0.15);
      addPart(smoothPct, 0.15);
      addPart(toneStability, 0.10);
      addPart(clarity, 0.10);
      let overall = null;
      if (parts.length) {
        const wsum = parts.reduce((s, p) => s + p.weight, 0);
        overall = parts.reduce((s, p) => s + p.score * p.weight, 0) / wsum;
      }
      return {
        pitchAccuracy: pitch,
        volumeConsistency: vol,
        toneSmoothness: smoothPct,
        toneStability,
        clarity,
        overall,
      };
    }

    const resolveUrl = (path, base) => {
      if (!path) return "";
      if (path.startsWith("http://") || path.startsWith("https://")) return path;
      // For ../audio_files/* keep as-is relative to dashboard dir
      try { return new URL(path, base || window.location.href).href; } catch { return path; }
    };

    function normalizeRuns(data, baseUrl) {
      const arr = data.runs || [];
      return arr.map(r => {
        const take =
          r.take ||
          (r.metadata && r.metadata.vocal_path && r.metadata.vocal_path.split("/").pop().replace(/\.[^.]+$/, "")) ||
          "take";
        return { ...r, take, baseUrl };
      });
    }

    function renderVolume(run) {
      const frames = run.volume?.frames || [];
      const ctx = document.getElementById("volumeChart").getContext("2d");
      if (!frames.length) {
        if (volumeChart) volumeChart.destroy();
        volumeChart = null;
        return;
      }
      const rmsPoints = frames.map(f => ({ x: f.time, y: f.rms_db ?? null })).filter(p => p.y !== null);
      const smoothPoints = frames.map(f => ({ x: f.time, y: f.rms_db_smooth ?? null })).filter(p => p.y !== null);
      const timeMin = Math.min(...frames.map(f => f.time), 0);
      const timeMax = Math.max(...frames.map(f => f.time), 0);
      if (volumeChart) volumeChart.destroy();
      volumeChart = new Chart(ctx, {
        type: "line",
        data: {
          datasets: [
            { label: "RMS (dB)", data: rmsPoints, parsing: false, borderColor: "rgba(249,115,22,0.75)", backgroundColor: "rgba(249,115,22,0.2)", borderWidth: 1.5, pointRadius: 0, spanGaps: false, yAxisID: "y" },
            { label: "Smoothed RMS (dB)", data: smoothPoints, parsing: false, borderColor: "rgba(34,197,94,0.85)", backgroundColor: "rgba(34,197,94,0.15)", borderWidth: 2, pointRadius: 0, spanGaps: true, yAxisID: "y" },
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { mode: "index", intersect: false },
          plugins: { legend: { labels: { color: "#fff" } } },
          scales: {
            x: {
              type: "linear",
              min: timeMin,
              max: timeMax,
              title: { display: true, text: "Seconds", color: "#fff" },
              ticks: {
                color: "#fff",
                stepSize: 0.5,
                callback: (v) => Number(v).toFixed(1),
              },
              grid: { color: "rgba(255,255,255,0.05)" }
            },
            y: { title: { display: true, text: "Relative Level (dB)", color: "#fff" }, ticks: { color: "#fff" }, grid: { color: "rgba(255,255,255,0.08)" } }
          }
        }
      });
    }

    function renderToneSmooth(run) {
      const frames = run.tone?.frames || [];
      const ctx = document.getElementById("toneChart").getContext("2d");
      if (!frames.length) {
        if (toneChart) toneChart.destroy();
        toneChart = null;
        return;
      }
      const smoothed = frames.map(f => ({ x: f.time, y: f.smoothed_midi ?? null })).filter(p => p.y !== null);
      const deltas = frames.map(f => ({ x: f.time, y: f.delta_cents ?? null })).filter(p => p.y !== null);
      const timeMin = Math.min(...frames.map(f => f.time), 0);
      const timeMax = Math.max(...frames.map(f => f.time), 0);
      if (toneChart) toneChart.destroy();
      toneChart = new Chart(ctx, {
        type: "line",
        data: {
          datasets: [
            { label: "Smoothed MIDI", data: smoothed, parsing: false, borderColor: "rgba(56,189,248,0.9)", backgroundColor: "rgba(56,189,248,0.2)", borderWidth: 2, pointRadius: 0, spanGaps: false, yAxisID: "y" },
            { label: "Δ cents", data: deltas, parsing: false, borderColor: "rgba(249,115,22,0.9)", backgroundColor: "rgba(249,115,22,0.2)", borderWidth: 1.5, pointRadius: 0, spanGaps: false, yAxisID: "y2" },
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { mode: "index", intersect: false },
          plugins: { legend: { labels: { color: "#fff" } } },
          scales: {
            x: {
              type: "linear",
              min: timeMin,
              max: timeMax,
              title: { display: true, text: "Seconds", color: "#fff" },
              ticks: { color: "#fff", stepSize: 0.5 },
              grid: { color: "rgba(255,255,255,0.05)" }
            },
            y: { position: "left", title: { display: true, text: "Smoothed MIDI", color: "#fff" }, ticks: { color: "#fff" }, grid: { color: "rgba(255,255,255,0.08)" } },
            y2: { position: "right", title: { display: true, text: "Δ cents/frame", color: "#fff" }, ticks: { color: "#fff" }, grid: { display: false } }
          }
        }
      });
    }

    function renderToneSpectral(run) {
      const frames = run.tone?.frames || [];
      const ctx = document.getElementById("toneSpectralChart").getContext("2d");
      if (!frames.length) {
        if (toneSpectralChart) toneSpectralChart.destroy();
        toneSpectralChart = null;
        return;
      }
      const centroid = frames.map(f => ({ x: f.time, y: f.centroid_hz ?? null })).filter(p => p.y !== null);
      const flatness = frames.map(f => ({ x: f.time, y: f.flatness ?? null })).filter(p => p.y !== null);
      const jitter = frames.map(f => ({ x: f.time, y: f.jitter ?? null })).filter(p => p.y !== null);
      const shimmer = frames.map(f => ({ x: f.time, y: f.shimmer ?? null })).filter(p => p.y !== null);
      const timeMin = Math.min(...frames.map(f => f.time), 0);
      const timeMax = Math.max(...frames.map(f => f.time), 0);
      if (toneSpectralChart) toneSpectralChart.destroy();
      toneSpectralChart = new Chart(ctx, {
        type: "line",
        data: {
          datasets: [
            { label: "Centroid (Hz)", data: centroid, parsing: false, borderColor: "rgba(56,189,248,0.9)", backgroundColor: "rgba(56,189,248,0.2)", borderWidth: 2, pointRadius: 0, spanGaps: false, yAxisID: "y" },
            { label: "Flatness", data: flatness, parsing: false, borderColor: "rgba(34,197,94,0.85)", backgroundColor: "rgba(34,197,94,0.15)", borderWidth: 2, pointRadius: 0, spanGaps: true, yAxisID: "y2" },
            { label: "Jitter", data: jitter, parsing: false, borderColor: "rgba(249,115,22,0.8)", backgroundColor: "rgba(249,115,22,0.15)", borderWidth: 1.5, pointRadius: 0, spanGaps: true, yAxisID: "y3" },
            { label: "Shimmer", data: shimmer, parsing: false, borderColor: "rgba(94,234,212,0.8)", backgroundColor: "rgba(94,234,212,0.15)", borderWidth: 1.5, pointRadius: 0, spanGaps: true, yAxisID: "y3" },
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { mode: "index", intersect: false },
          plugins: { legend: { labels: { color: "#fff" } } },
          scales: {
            x: {
              type: "linear",
              min: timeMin,
              max: timeMax,
              title: { display: true, text: "Seconds", color: "#fff" },
              ticks: { color: "#fff", stepSize: 0.5 },
              grid: { color: "rgba(255,255,255,0.05)" }
            },
            y: { position: "left", title: { display: true, text: "Centroid (Hz)", color: "#fff" }, ticks: { color: "#fff" }, grid: { color: "rgba(255,255,255,0.08)" } },
            y2: { position: "right", title: { display: true, text: "Flatness", color: "#fff" }, ticks: { color: "#fff" }, grid: { display: false } },
            y3: { position: "right", title: { display: true, text: "Jitter/Shimmer", color: "#fff" }, ticks: { color: "#fff" }, grid: { display: false }, offset: true },
          }
        }
      });
    }

    async function loadData() {
      const resp = await fetch(`${DATA_URL}?ts=${Date.now()}`, { cache: 'no-store' });
      if (!resp.ok) throw new Error("Could not load analysis_similarity.json");
      const data = await resp.json();
      const baseUrl = resp.url;
      runs = normalizeRuns(data, baseUrl);
      if (runs.length && !selected) selected = runs[0].take;
      renderTakeSelect();
      renderScores();
      renderTake(selected);
    }

    function renderTakeSelect() {
      const sel = document.getElementById("takeSelect");
      sel.innerHTML = runs.map((r, i) => `<option value="${r.take}">${r.take}</option>`).join("");
      if (selected) sel.value = selected;
      sel.onchange = () => {
        selected = sel.value;
        renderTake(selected);
        renderScores();
      };
    }

    function setAudioSources(run) {
      const meta = run.metadata || {};
      const base = run.baseUrl || window.location.href;
      audioEls.vocal.src = resolveUrl(meta.vocal_path, base);
      audioEls.ref.src = resolveUrl(meta.reference_path, base);
      audioEls.vocal.load(); audioEls.ref.load();
      duration = Math.max(meta.duration_vocal || 0, meta.duration_reference || 0, run.frames?.at(-1)?.time || 0);
      if (duration <= 0) duration = 1;
      playheadTime = 0;
      document.getElementById("seek").max = duration;
      document.getElementById("seek").value = 0;
      document.getElementById("timeLabel").textContent = `${fmtTime(0)} / ${fmtTime(duration)}`;
    }

    function togglePlay(play) {
      const shouldPlay = play ?? !isPlaying;
      isPlaying = shouldPlay && (audioEls.vocal.src || audioEls.ref.src);
      if (isPlaying) {
        if (document.getElementById("vocalToggle").checked) audioEls.vocal.play().catch(() => { });
        if (document.getElementById("refToggle").checked) audioEls.ref.play().catch(() => { });
      } else {
        audioEls.vocal.pause(); audioEls.ref.pause();
      }
      document.getElementById("playPause").textContent = isPlaying ? "❚❚" : "▶";
      requestAnimationFrame(updatePlayhead);
    }

    function updatePlayhead() {
      const master = document.getElementById("vocalToggle").checked ? audioEls.vocal : audioEls.ref;
      playheadTime = master.currentTime || 0;
      document.getElementById("seek").value = playheadTime;
      document.getElementById("timeLabel").textContent = `${fmtTime(playheadTime)} / ${fmtTime(duration)}`;
      if (melodyChart) melodyChart.update('none');
      if (volumeChart) volumeChart.update('none');
      if (isPlaying) requestAnimationFrame(updatePlayhead);
    }

    function renderCards(summary = {}, takeName = "", volumeSummary = null) {
      const cards = [
        { title: "Take", value: takeName || "—", color: "var(--text)" },
        { title: "Accuracy (±50c)", value: fmt(summary.pct_within_50, 1) + "%", color: "var(--accent2)" },
        { title: "Accuracy (±25c)", value: fmt(summary.pct_within_25, 1) + "%", color: "var(--accent2)" },
        { title: "Accuracy (±100c)", value: fmt(summary.pct_within_100, 1) + "%", color: "var(--accent2)" },
        { title: "Mean Abs Cents", value: fmt(summary.mean_abs_cents, 1) + " c", color: "var(--muted)" },
        { title: "Valid Frames", value: summary.valid_frames ?? 0, color: "var(--muted)" },
      ];
      if (volumeSummary) {
        cards.push(
          { title: "Volume std", value: fmt(volumeSummary.std_db, 1) + " dB", color: "var(--accent)" },
          { title: `Vol within ±${fmt(volumeSummary.tolerance_db, 1)} dB`, value: fmt(volumeSummary.pct_within_tolerance, 1) + "%", color: "var(--accent2)" },
        );
      }
      document.getElementById("cards").innerHTML = cards.map(c => `
        <div class="card"><h3>${c.title}</h3><div class="value" style="color:${c.color}">${c.value}</div></div>
      `).join("");
    }
    function renderToneProfile(run) {
      const ctx = document.getElementById("toneProfileChart").getContext("2d");
      const categories = run.tone?.summary?.spectral?.categories || null;
      if (!categories) {
        if (toneProfileChart) toneProfileChart.destroy();
        toneProfileChart = null;
        document.getElementById("toneMetrics").innerHTML = "";
        return;
      }

      const labels = [
        "Brightness",
        "Noisiness",
        "Tilt (Warm→Bright)",
        "Clarity",
        "Breathy→Pressed"
      ];
      const values = [
        categories.brightness?.score ?? null,
        categories.noisiness?.score ?? null,
        categories.tilt_warm_to_bright?.score ?? null,
        categories.clarity?.score ?? null,
        categories.breathiness_to_pressed?.score ?? null,
      ];

      // If all values are null, skip rendering
      if (values.every(v => v == null)) {
        if (toneProfileChart) toneProfileChart.destroy();
        toneProfileChart = null;
        document.getElementById("toneMetrics").innerHTML = "";
        return;
      }

      if (toneProfileChart) toneProfileChart.destroy();
      toneProfileChart = new Chart(ctx, {
        type: "radar",
        data: {
          labels,
          datasets: [{
            label: "Tone Profile (1–10)",
            data: values,
            borderWidth: 2,
            pointRadius: 3,
            fill: true,
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { labels: { color: "#fff" } },
            tooltip: {
              callbacks: {
                label: (ctx) => {
                  const label = ctx.label || "";
                  const v = ctx.raw;
                  const desc = toneHelp[label]?.meaning || "";
                  const improve = toneHelp[label]?.improve || "";
                  return [`${label}: ${fmt(v, 1)} / 10`, desc ? `Meaning: ${desc}` : "", improve ? `Improve: ${improve}` : ""].filter(Boolean);
                }
              }
            }
          },
          scales: {
            r: {
              min: 1,
              max: 10,
              ticks: {
                stepSize: 1,
                color: "#fff",
              },
              angleLines: { color: "rgba(255,255,255,0.15)" },
              grid: { color: "rgba(255,255,255,0.15)" },
              pointLabels: { color: "#fff" }
            }
          }
        }
      });

      // Render tone metrics list below radar
      const sm = run.tone?.summary?.smoothness;
      const spectral = run.tone?.summary?.spectral;
      const jitter = run.tone?.summary?.jitter;
      const shimmer = run.tone?.summary?.shimmer;
      const metrics = [];
      if (sm) {
        metrics.push({ label: "Tone mean |Δ|", value: `${fmt(sm.mean_abs_delta_cents, 1)} c`, tip: "Tone mean |Δ|" });
        metrics.push({ label: "Tone median |Δ|", value: `${fmt(sm.median_abs_delta_cents, 1)} c`, tip: "Tone median |Δ|" });
        metrics.push({ label: `Tone within ±${fmt(sm.tolerance_cents_per_step, 0)}c`, value: `${fmt(sm.pct_within_tolerance, 1)}%`, tip: "Tone within ±20c" });
      }
      const addCat = (key, label) => {
        const score = categories[key]?.score;
        if (score != null && !Number.isNaN(score)) metrics.push({ label, value: `${fmt(score, 1)} / 10`, tip: label });
      };
      addCat("brightness", "Brightness");
      addCat("noisiness", "Noisiness");
      addCat("tilt_warm_to_bright", "Tilt (Warm→Bright)");
      addCat("clarity", "Clarity");
      addCat("breathiness_to_pressed", "Breathy→Pressed");
      if (jitter && jitter.mean != null) metrics.push({ label: "Jitter (mean)", value: fmt(jitter.mean, 3), tip: "Jitter (mean)" });
      if (shimmer && shimmer.mean != null) metrics.push({ label: "Shimmer (mean)", value: fmt(shimmer.mean, 3), tip: "Shimmer (mean)" });

      const toneMetricsEl = document.getElementById("toneMetrics");
      toneMetricsEl.innerHTML = metrics.map(m => {
        const tip = toneHelp[m.tip || m.label]?.meaning || "";
        const improve = toneHelp[m.tip || m.label]?.improve;
        const title = [tip, improve ? `Improve: ${improve}` : ""].filter(Boolean).join("\n");
        return `<div class="tone-metric" title="${title}"><span>${m.label}</span><strong>${m.value}</strong></div>`;
      }).join("");

      // Tips block
      const tips = [];
      ["Brightness", "Noisiness", "Tilt (Warm→Bright)", "Clarity", "Breathy→Pressed", "Tone mean |Δ|", "Tone median |Δ|", "Tone within ±20c", "Jitter (mean)", "Shimmer (mean)"].forEach(key => {
        const desc = toneHelp[key]?.meaning;
        const improve = toneHelp[key]?.improve;
        if (desc || improve) {
          tips.push(`<div><strong>${key}</strong>: ${desc || ""}${improve ? ` <em>Improve:</em> ${improve}` : ""}</div>`);
        }
      });
      document.getElementById("toneTips").innerHTML = tips.join("<br>");
    }

    function renderMelody(run) {
      const frames = run.frames || [];
      const vocalPoints = frames.map(f => ({ x: f.time, y: f.vocal_midi ?? null }));
      const refPoints = frames.map(f => ({ x: f.time, y: f.ref_midi ?? null }));
      const timeMin = Math.min(...frames.map(f => f.time), 0);
      const timeMax = Math.max(...frames.map(f => f.time), duration, 0);
      const ctx = document.getElementById("melodyChart").getContext("2d");
      if (melodyChart) melodyChart.destroy();
      melodyChart = new Chart(ctx, {
        type: "scatter",
        data: {
          datasets: [
            { label: "Vocal (MIDI)", data: vocalPoints, showLine: true, borderColor: "rgba(56,189,248,0.9)", backgroundColor: "rgba(56,189,248,0.2)", borderWidth: 2, pointRadius: 0, spanGaps: false, parsing: false, tension: 0 },
            { label: "Reference (MIDI)", data: refPoints, showLine: true, borderColor: "rgba(34,197,94,0.9)", backgroundColor: "rgba(34,197,94,0.2)", borderWidth: 2, pointRadius: 0, spanGaps: false, parsing: false, tension: 0 }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { mode: "index", intersect: false },
          plugins: { legend: { labels: { color: "#fff" } } },
          scales: {
            x: { title: { display: true, text: "Time (s)", color: "#fff" }, ticks: { color: "#fff" }, grid: { color: "rgba(255,255,255,0.05)" }, min: timeMin, max: timeMax },
            y: { title: { display: true, text: "MIDI", color: "#fff" }, ticks: { color: "#fff" }, grid: { color: "rgba(255,255,255,0.08)" } }
          }
        }
      });

      // Scrub by clicking/dragging on chart
      const scrub = (evt) => {
        const xVal = melodyChart.scales.x.getValueForPixel(evt.offsetX);
        if (!Number.isFinite(xVal)) return;
        const t = Math.max(0, Math.min(xVal, duration));
        playheadTime = t;
        audioEls.vocal.currentTime = t;
        audioEls.ref.currentTime = t;
        document.getElementById("seek").value = t;
        document.getElementById("timeLabel").textContent = `${fmtTime(t)} / ${fmtTime(duration)}`;
        melodyChart.update('none');
      };
      let dragging = false;
      melodyChart.canvas.onpointerdown = (e) => { dragging = true; scrub(e); };
      melodyChart.canvas.onpointermove = (e) => { if (dragging) scrub(e); };
      window.onpointerup = () => { dragging = false; };
    }

    function renderScores() {
      const labels = runs.map(r => r.take);
      const pitchScores = [];
      const overallScores = [];
      const pitchColors = [];
      const overallColors = [];
      for (const r of runs) {
        const s = computeTakeScores(r);
        pitchScores.push(s.pitchAccuracy);
        overallScores.push(s.overall);
        const isSel = r.take === selected;
        pitchColors.push(isSel ? "#60a5fa" : "rgba(96,165,250,0.6)");
        overallColors.push(isSel ? "#f97316" : "rgba(249,115,22,0.7)");
      }
      const ctx = document.getElementById("scoresChart").getContext("2d");
      if (scoresChart) scoresChart.destroy();
      scoresChart = new Chart(ctx, {
        type: "bar",
        data: {
          labels,
          datasets: [
            {
              label: "Pitch Accuracy (±50c, %)",
              data: pitchScores,
              backgroundColor: pitchColors,
            },
            {
              label: "Overall Take Quality (0–100)",
              data: overallScores,
              backgroundColor: overallColors,
            },
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              max: 100,
              title: { display: true, text: "Score (0–100)", color: "#fff" },
              ticks: { color: "#fff" },
              grid: { color: "rgba(255,255,255,0.08)" }
            },
            x: {
              ticks: { color: "#fff" },
              grid: { color: "rgba(255,255,255,0.05)" }
            }
          },
          plugins: {
            legend: { display: true, labels: { color: "#fff" } }
          },
          onClick: (_, el) => {
            if (el?.length) {
              const idx = el[0].index;
              selected = labels[idx];
              renderTake(selected);
              renderScores();
            }
          }
        }
      });
    }

    function renderTake(takeName) {
      const run = runs.find(r => r.take === takeName);
      if (!run) return;
      selected = takeName;
      setAudioSources(run);
      renderCards(run.summary || {}, takeName, run.volume?.summary, run.tone?.summary);
      renderMelody(run);
      renderVolume(run);
      renderToneSmooth(run);
      renderToneSpectral(run);
      renderToneProfile(run);
    }

    document.getElementById("playPause").onclick = () => togglePlay();
    document.getElementById("seek").oninput = (e) => {
      const t = Number(e.target.value);
      playheadTime = t;
      audioEls.vocal.currentTime = t;
      audioEls.ref.currentTime = t;
      document.getElementById("timeLabel").textContent = `${fmtTime(t)} / ${fmtTime(duration)}`;
      if (melodyChart) melodyChart.update('none');
      if (volumeChart) volumeChart.update('none');
      if (toneChart) toneChart.update('none');
      if (toneSpectralChart) toneSpectralChart.update('none');
    };
    document.getElementById("vocalToggle").onchange = () => { if (!document.getElementById("vocalToggle").checked) audioEls.vocal.pause(); };
    document.getElementById("refToggle").onchange = () => { if (!document.getElementById("refToggle").checked) audioEls.ref.pause(); };
    document.getElementById("reload").onclick = loadData;

    audioEls.vocal.addEventListener("timeupdate", () => {
      if (!isPlaying) return;
      playheadTime = audioEls.vocal.currentTime;
    });
    audioEls.ref.addEventListener("timeupdate", () => {
      if (!isPlaying) return;
      // keep ref aligned to vocal if vocal is enabled
      if (document.getElementById("vocalToggle").checked) {
        const delta = Math.abs(audioEls.ref.currentTime - audioEls.vocal.currentTime);
        if (delta > 0.05) audioEls.ref.currentTime = audioEls.vocal.currentTime;
      }
    });

    // Auto-refresh every 15s to pick up new takes
    setInterval(loadData, 15000);
    loadData().catch(err => console.error(err));
  </script>
</body>

</html>
